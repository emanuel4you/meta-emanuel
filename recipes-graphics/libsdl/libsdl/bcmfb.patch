diff -Nur SDL-1.2.15/configure SDL-bcmfb-1.2.15/configure
--- SDL-1.2.15/configure	2012-01-19 07:30:12.000000000 +0100
+++ SDL-bcmfb-1.2.15/configure	2016-02-16 00:03:07.493192883 +0100
@@ -1552,6 +1552,7 @@
   --enable-video-carbon   use Carbon/QuickDraw video driver [default=no]
   --enable-video-cocoa    use Cocoa/Quartz video driver [default=yes]
   --enable-video-fbcon    use framebuffer console video driver [default=yes]
+  --enable-video-bcmfb    use bcmfb framebuffer console video driver [default=yes]
   --enable-video-directfb use DirectFB video driver [default=yes]
   --enable-video-ps2gs    use PlayStation 2 GS video driver [default=yes]
   --enable-video-ps3      use PlayStation 3 Cell driver [default=yes]
@@ -24851,6 +24852,174 @@
     fi
 }
 
+CheckBCMFB()
+{
+    # Check whether --enable-video-bcmfb was given.
+if test "${enable_video_bcmfb+set}" = set; then
+  enableval=$enable_video_bcmfb;
+else
+  enable_video_bcmfb=yes
+fi
+
+    if test x$enable_video = xyes -a x$enable_video_bcmfb = xyes; then
+        { echo "$as_me:$LINENO: checking for framebuffer console support" >&5
+echo $ECHO_N "checking for framebuffer console support... $ECHO_C" >&6; }
+        video_bcmfb=no
+        cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+         #include <linux/fb.h>
+         #include <linux/kd.h>
+         #include <linux/keyboard.h>
+
+int
+main ()
+{
+
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+        video_bcmfb=yes
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+        { echo "$as_me:$LINENO: result: $video_bcmfb" >&5
+echo "${ECHO_T}$video_bcmfb" >&6; }
+        if test x$video_bcmfb = xyes; then
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_VIDEO_DRIVER_BCMFB 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/video/bcmfb/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
 CheckDirectFB()
 {
     # Check whether --enable-video-directfb was given.
@@ -29556,6 +29725,7 @@
         CheckX11
         CheckNANOX
         CheckFBCON
+        CheckBCMFB
         CheckDirectFB
         CheckPS2GS
         CheckPS3
diff -Nur SDL-1.2.15/configure.in SDL-bcmfb-1.2.15/configure.in
--- SDL-1.2.15/configure.in	2012-01-19 07:30:05.000000000 +0100
+++ SDL-bcmfb-1.2.15/configure.in	2016-02-16 00:03:07.493192883 +0100
@@ -1252,6 +1252,33 @@
     fi
 }
 
+dnl Find the bcmfb framebuffer console includes
+CheckBCMFB()
+{
+    AC_ARG_ENABLE(video-bcmfb,
+AC_HELP_STRING([--enable-video-bcmfb], [use framebuffer console video driver [[default=yes]]]),
+                  , enable_video_bcmfb=yes)
+    if test x$enable_video = xyes -a x$enable_video_bcmfb = xyes; then
+        AC_MSG_CHECKING(for framebuffer console support)
+        video_bcmfb=no
+        AC_TRY_COMPILE([
+         #include <linux/fb.h>
+         #include <linux/kd.h>
+         #include <linux/keyboard.h>
+        ],[
+        ],[
+        video_bcmfb=yes
+        ])
+        AC_MSG_RESULT($video_bcmfb)
+        if test x$video_bcmfb = xyes; then
+            AC_CHECK_FUNCS(getpagesize)
+            AC_DEFINE(SDL_VIDEO_DRIVER_BCMFB)
+            SOURCES="$SOURCES $srcdir/src/video/bcmfb/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
 dnl Find DirectFB
 CheckDirectFB()
 {
@@ -2363,6 +2390,7 @@
         CheckX11
         CheckNANOX
         CheckFBCON
+        CheckBCMFB
         CheckDirectFB
         CheckPS2GS
         CheckPS3
diff -Nur SDL-1.2.15/include/SDL_config.h.in SDL-bcmfb-1.2.15/include/SDL_config.h.in
--- SDL-1.2.15/include/SDL_config.h.in	2012-01-19 07:30:05.000000000 +0100
+++ SDL-bcmfb-1.2.15/include/SDL_config.h.in	2016-02-16 00:03:07.493192883 +0100
@@ -263,6 +263,7 @@
 #undef SDL_VIDEO_DRIVER_DRAWSPROCKET
 #undef SDL_VIDEO_DRIVER_DUMMY
 #undef SDL_VIDEO_DRIVER_FBCON
+#undef SDL_VIDEO_DRIVER_BCMFB
 #undef SDL_VIDEO_DRIVER_GAPI
 #undef SDL_VIDEO_DRIVER_GEM
 #undef SDL_VIDEO_DRIVER_GGI
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_bcmfb.c SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_bcmfb.c
--- SDL-1.2.15/src/video/bcmfb/SDL_bcmfb.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_bcmfb.c	2016-02-16 15:57:35.000000000 +0100
@@ -0,0 +1,468 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+
+#include "SDL_config.h"
+#include "SDL_video.h"
+#include "../SDL_blit.h"
+#include "../SDL_surface.h"
+#include "SDL_bcmfb.h"
+
+
+/* SDL_bcmfb */
+int bcm_accel_init()
+{
+	if (exec_list())
+	{
+		return 1;
+	}
+	else {
+		fprintf(stderr, "BCMFB accel interface found\n");
+	}
+	
+	/* old 0x80
+	P(0x80, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x50 not available\n");
+		supportblendingflags = 0;
+	}
+	P(0x50, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x50 not available\n");
+		supportblendingflags = 0;
+	}
+	
+	P(0x48, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x48 not available\n");
+		supportblendingflags = 0;
+	}
+	P(0x6c, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x6c not available\n");
+		supportblendingflags = 0;
+	}
+	P(0x4c, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x4c not available\n");
+		supportblendingflags = 0;
+	}
+	*/
+	
+	/* now test for blending flags support */
+	P(0x60, 0);
+	if (exec_list())
+	{
+		fprintf(stderr, "BCMFB support blending flags 0x60 not available\n");
+		supportblendingflags = 0;
+	}
+	return 0;
+}
+
+static int exec_list()
+{
+	SDL_VideoDevice *this = current_video;
+	int ret;
+	struct
+	{
+		void *ptr;
+		int len;
+	} l;
+
+	l.ptr = displaylist;
+	l.len = ptr;
+	ret = ioctl(console_fd, FBIO_ACCEL, &l);
+	ptr = 0;
+	if (ret != 0) {
+		SDL_SetError("BCMFB accel ioctl faild!");
+	}
+	return ret;
+}
+
+int bcm_accel_has_alphablending()
+{
+	return supportblendingflags;
+}
+
+void bcm_accel_fill(int dst_addr, int dst_width, int dst_height, int dst_stride, int bpp,
+		int x, int y, int width, int height,
+		int pal_addr, unsigned long color)
+{
+	C(0x43); // reset source
+	C(0x53); // reset dest
+	C(0x5b); // reset pattern
+	C(0x67); // reset blend
+	C(0x75); // reset output
+
+	// clear dest surface
+	P(0x0, 0);
+	P(0x1, 0);
+	P(0x2, 0);
+	P(0x3, 0);
+	P(0x4, 0);
+	C(0x45);
+
+	// clear src surface
+	P(0x0, 0);
+	P(0x1, 0);
+	P(0x2, 0);
+	P(0x3, 0);
+	P(0x4, 0);
+	C(0x5);
+
+	P(0x2d, color);
+
+	P(0x2e, x); // prepare output rect
+	P(0x2f, y);
+	P(0x30, width);
+	P(0x31, height);
+	C(0x6e); // set this rect as output rect
+
+	P(0x0, dst_addr); // prepare output surface
+	P(0x1, dst_stride);
+	P(0x2, dst_width);
+	P(0x3, dst_height);
+	
+	switch (bpp)
+	{
+	case 8:
+		P(0x4, 0x12e40008); // indexed 8bit
+		P(0x78, 256);
+		P(0x79, pal_addr);
+		P(0x7a, 0x7e48888);
+		break;
+	case 16:
+		P(0x4, 0x06e40565); // RGB_565 16 bit
+		break;
+	case 32:
+		P(0x4, 0x7e48888); // format: ARGB 8888
+		break;
+	}
+	
+	C(0x69); // set output surface
+
+	P(0x6f, 0);
+	P(0x70, 0);
+	P(0x71, 2);
+	P(0x72, 2);
+	C(0x73); // select color keying
+
+	C(0x77);  // do it
+
+	exec_list();
+}
+
+void bcm_accel_blit(int src_addr, int src_width, int src_height, int src_stride, int bpp,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight,
+		int pal_addr, int flags)
+{
+	C(0x43); // reset source
+	C(0x53); // reset dest
+	C(0x5b);  // reset pattern
+	C(0x67); // reset blend
+	C(0x75); // reset output
+
+	P(0x0, src_addr); // set source addr
+	P(0x1, src_stride);  // set source pitch
+	P(0x2, src_width); // source width
+	P(0x3, src_height); // height
+	switch (bpp)
+	{
+	case 8:
+		P(0x4, 0x12e40008); // indexed 8bit
+		P(0x78, 256);
+		P(0x79, pal_addr);
+		P(0x7a, 0x7e48888);
+		break;
+	case 16:
+		P(0x4, 0x06e40565); // RGB_565 16 bit
+		break;
+	case 32:
+		P(0x4, 0x7e48888); // format: ARGB 8888
+		break;
+	}
+
+	C(0x5); // set source surface (based on last parameters)
+
+	P(0x2e, src_x); // define  rect
+	P(0x2f, src_y);
+	P(0x30, width);
+	P(0x31, height);
+
+	C(0x32); // set this rect as source rect
+
+	P(0x0, dst_addr); // prepare output surface
+	P(0x1, dst_stride);
+	P(0x2, dst_width);
+	P(0x3, dst_height);
+	P(0x4, 0x7e48888);
+
+	C(0x69); // set output surface
+
+	P(0x2e, dst_x); // prepare output rect
+	P(0x2f, dst_y);
+	P(0x30, dwidth);
+	P(0x31, dheight);
+
+	C(0x6e); // set this rect as output rect
+
+	/* blend flags... 
+	 * We'd really like some blending support in the drivers,
+	 * to avoid punching holes in the osd 
+	 */
+	if (supportblendingflags && flags) P(0x80, flags);
+
+	C(0x77);  // do it
+
+	exec_list();
+}
+
+/* Wait for vertical retrace */
+static void WaitVBL(_THIS)
+{
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "WaitVBL\n");
+#endif
+
+#ifdef FBIOWAITRETRACE /* Heheh, this didn't make it into the main kernel */
+	ioctl(console_fd, FBIOWAITRETRACE, 0);
+#endif
+	return;
+}
+
+static void WaitIdle(_THIS)
+{
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "WaitIdle\n");
+#endif
+	return;
+}
+#if 0
+/* Sets video mem colorkey and accelerated blit function */
+static int SetHWColorKey(_THIS, SDL_Surface *surface, Uint32 key)
+{
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "SetHWColorKey\n");
+#endif
+	return(0);
+}
+#endif
+static int FillHWRect(_THIS, SDL_Surface *dst, SDL_Rect *rect, Uint32 color)
+{
+	Uint32 dst_base;
+	int rectX, rectY, rectW, rectH,
+		dst_width, dst_height, dst_addr,
+		pal_addr, bpp, bypp, stride, fb_size;
+	unsigned long dst_color;
+
+	/* Set the destination pixel format */
+	bpp = dst->format->BitsPerPixel;
+	bypp = bpp/8;
+	
+	/* convert color */
+	dst_color = (unsigned long)color;
+	
+	/* Calculate base coordinates */
+	rectX = rect->x;
+	rectY = rect->y;
+	rectW = rect->w;
+	rectH = rect->h;
+	
+	/* Calculate destination base coordinates */
+	dst_width = dst->w;
+	dst_height = dst->h;
+	stride = dst_width * bypp;
+	
+	if ( dst == this->screen ) {
+		SDL_mutexP(hw_lock);
+	}
+				
+	/* set current pal */
+	pal_addr = this->physpal;
+	
+	/* Calculate destination base address */
+	dst_addr =  (Uint8 *)dst->pixels +
+				(Uint16)rect->y*dst->pitch +
+				(Uint16)rect->x*dst->format->BytesPerPixel;
+
+	/* Calculate fb_size for destination */
+	fb_size = stride * dst_height;
+	
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "FillHWRect - dst_addr: %p\n\t dst_width: %d\n\t dst_height: %d\n\t stride: %d\n\t rectX: %d\n\t rectY: %d\n\t rectW: %d\n\t rectH: %d\n\t color: %d\n", 
+					dst_addr, dst_width, dst_height, stride,
+					rectX, rectY, rectW, rectH, dst_color);
+#endif
+
+	/* now accel */
+	bcm_accel_fill(dst_addr, dst_width, dst_height, stride, bpp,
+					rectX, rectY, rectW, rectH, pal_addr, dst_color);
+	
+	BCMFB_AddBusySurface(dst);
+	
+	if ( dst == this->screen ) {
+		SDL_mutexV(hw_lock);
+	}
+	return(0);
+}
+
+static int HWAccelBlit(SDL_Surface *src, SDL_Rect *srcrect,
+                       SDL_Surface *dst, SDL_Rect *dstrect)
+{
+	SDL_VideoDevice *this = current_video;
+	int src_addr, src_rectX, src_rectY, src_rectW, 
+		src_rectH, src_stride, dst_width, dst_height, 
+		dst_addr, dst_rectX, dst_rectY, dst_rectW, 
+		dst_rectH, dst_stride, src_width, src_height,
+		flip_addr, flip_size, bypp, bpp, pal_addr, flags;
+	
+	/* Set the destination pixel format */
+	bpp = dst->format->BitsPerPixel;
+	bypp = bpp/8;
+	
+	/* Calculate destination base coordinates */
+	dst_rectX = dstrect->x;
+	dst_rectY = dstrect->y;
+	dst_rectW = dstrect->w;
+	dst_rectH = dstrect->h;
+	dst_width = dst->w;
+	dst_height = dst->h;
+	dst_stride = dst_width * bypp;
+
+	/* Calculate source base coordinates */
+	src_rectX = srcrect->x;
+	src_rectY = srcrect->y;
+	src_rectW = srcrect->w;
+	src_rectH = srcrect->h;
+	src_width = src->w;
+	src_height = src->h;
+	src_stride = src_width * bypp;
+	
+	/* Calculate source base address */
+	src_addr = (Uint8 *)src->pixels +
+				(Uint16)srcrect->y*src->pitch +
+				(Uint16)srcrect->x*src->format->BytesPerPixel;
+	
+	/* Calculate destination address */	
+	dst_addr =	(Uint8 *)accel_mem +
+				(Uint16)dstrect->y * dst->pitch +
+				(Uint16)dstrect->x * dst->format->BytesPerPixel;
+	
+	/* Calculate end destination address */
+	flip_addr = (Uint8 *)dst->pixels +
+				(Uint16)dstrect->y * dst->pitch +
+				(Uint16)dstrect->x * dst->format->BytesPerPixel;
+				
+	flip_size = dstrect->y * dst_stride;
+	
+	/* init flags */
+	flags = 0;
+	if ( (src->flags & SDL_SRCALPHA) ) {
+		flags += blitAlphaTest;
+		flags += blitAlphaBlend;
+	}
+	if ((src_rectX != dst_rectX) || (src_rectY != dst_rectY)) {
+		flags += blitScale;
+	}
+	if ((src_width == dst_width) && (src_height == dst_height)) {
+		flags += blitKeepAspectRatio;
+	}
+	
+	/* set current pal */
+	pal_addr = this->physpal;
+	
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "HWAccelBlit - dst_addr: %p\n\t dst_width: %d\n\t dst_height: %d\n\t dst_stride: %d\n\t dst_rectX: %d\n\t dst_rectY: %d\n\t dst_rectW: %d\n\t dst_rectH: %d\n", 
+					dst_addr, dst_width, dst_height, dst_stride, 
+					dst_rectX, dst_rectY, dst_rectW, dst_rectH);
+					
+	fprintf(stderr, "HWAccelBlit - src_addr: %p\n\t src_width: %d\n\t src_height: %d\n\t src_stride: %d\n\t src_rectX: %d\n\t src_rectY: %d\n\t src_rectW: %d\n\t src_rectH: %d\n\t flip_addr: %p\n\t flip_size: %d\n", 
+					src_addr, src_width, src_height, src_stride, 
+					src_rectX, src_rectY, src_rectW, src_rectH, flip_addr, flip_size);
+#endif
+
+	/* now accel */
+	bcm_accel_blit(src_addr, src_width, src_height, src_stride, bpp,
+					dst_addr, dst_width, dst_height, dst_stride,
+					src_rectX, src_rectY, src_rectW, src_rectH,
+					dst_rectX, dst_rectY, dst_rectW, dst_rectH,
+					pal_addr, flags);
+					
+	/* flip rect to screen */
+	memcpy(flip_addr, src_addr, flip_size);
+		
+	BCMFB_AddBusySurface(dst);
+	
+	if ( dst == this->screen ) {
+		SDL_mutexV(hw_lock);
+	}
+	
+	return(0);
+}
+
+static int CheckHWBlit(_THIS, SDL_Surface *src, SDL_Surface *dst)
+{
+	if (!bcm_can_accel(dst)) {
+		return 0;
+	}
+	
+	int accelerated;
+
+	/* Set initial acceleration on */
+	src->flags |= SDL_HWACCEL;
+
+	/* Set the surface attributes */
+	if ( (src->flags & SDL_SRCALPHA) == SDL_SRCALPHA ) {
+		if ( ! this->info.blit_hw_A ) {
+			src->flags &= ~SDL_HWACCEL;
+		}
+	}
+	if ( (src->flags & SDL_SRCCOLORKEY) == SDL_SRCCOLORKEY ) {
+		if ( ! this->info.blit_hw_CC ) {
+			src->flags &= ~SDL_HWACCEL;
+		}
+	}
+
+	/* Check to see if final surface blit is accelerated */
+	accelerated = !!(src->flags & SDL_HWACCEL);
+	if ( accelerated ) {
+		src->map->hw_blit = HWAccelBlit;
+	}
+#ifdef BCMFB_ACCEL_DEBUG
+	fprintf(stderr, "CheckHWBlit - return(accelerated=%d)n", accelerated);
+#endif
+	return(accelerated);
+}
+
+void BCMFB_Accel(_THIS, __u32 card)
+{
+	/* We have hardware accelerated surface functions */
+	this->CheckHWBlit = CheckHWBlit;
+	wait_vbl = WaitVBL;
+	wait_idle = WaitIdle;
+
+	/* The BCMFB has an accelerated color fill */
+	this->info.blit_fill = 1;
+	this->FillHWRect = FillHWRect;
+
+	/* The BCMFB has accelerated blit */
+	this->info.blit_hw = 1;
+	this->info.blit_hw_A = 1;
+}
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_bcmfb.h SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_bcmfb.h
--- SDL-1.2.15/src/video/bcmfb/SDL_bcmfb.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_bcmfb.h	2016-02-16 15:52:00.000000000 +0100
@@ -0,0 +1,48 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+/* Broadcom hardware acceleration for the SDL framebuffer console driver */
+
+#include "SDL_fbvideo.h"
+
+/* Set up the driver for acceleration */
+
+#define FB_ACCEL_VC4 0xb0
+#define FBIO_ACCEL 0x23
+
+#define blitAlphaTest 1
+#define blitAlphaBlend 2
+#define blitScale 4
+#define blitKeepAspectRatio 8
+
+static unsigned int displaylist[1024];
+static int ptr;
+static int supportblendingflags = 1;
+
+#define P(x, y) do { displaylist[ptr++] = x; displaylist[ptr++] = y; } while (0)
+#define C(x) P(x, 0)
+
+static int exec_list();
+extern int bcm_accel_init();
+
+extern void bcm_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int bpp,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight,
+		int pal_addr, int flags);
+
+extern void bcm_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride, int bpp,
+		int x, int y, int width, int height,
+		int pal_addr, unsigned long color);
+
+extern int bcm_accel_has_alphablending();
+
+extern void BCMFB_Accel(_THIS, __u32 card);
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbevents.c SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbevents.c
--- SDL-1.2.15/src/video/bcmfb/SDL_fbevents.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbevents.c	2016-02-11 23:49:17.000000000 +0100
@@ -0,0 +1,723 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <limits.h>
+
+/* For parsing /proc */
+#include <dirent.h>
+#include <ctype.h>
+
+#include <linux/kd.h>
+#include <linux/keyboard.h>
+#include <linux/input.h>
+
+#include "SDL_timer.h"
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_fbvideo.h"
+#include "SDL_fbevents_c.h"
+
+#define DEBUG_KEYBOARD
+#define DEBUG_MOUSE
+
+static int posted = 0;
+static SDLKey KeyTranslate(unsigned short code, int type);
+
+void BCMFB_InitOSKeymap(_THIS)
+{
+	return;
+}
+
+int BCMFB_InGraphicsMode(_THIS)
+{
+	return(kbd_fd[0]);
+}
+
+int BCMFB_EnterGraphicsMode(_THIS)
+{
+	return(kbd_fd[0]);
+}
+
+void BCMFB_LeaveGraphicsMode(_THIS)
+{
+	return;
+}
+
+void BCMFB_CloseKeyboard(_THIS)
+{
+	int i;
+	for (i = 0; i < 32; i++) {
+		if (kbd_fd[i] != -1) {
+			close(kbd_fd[i]);
+		}
+		kbd_fd[i] = -1;
+	}
+	kbd_index = -1;
+	panel = -1;
+	kbd = -1;
+	arc = -1;
+	rc = -1;
+}
+
+int BCMFB_OpenKeyboard(_THIS)
+{
+	unsigned char mask[EV_MAX/8 + 1];
+	char device[64], name[128];
+	int type=0;
+	int fd, i, j;
+	
+	kbd_index = -1;
+	panel = -1;
+	kbd = -1;
+	arc = -1;
+	rc = -1;
+	for (i = 0; i < 32; i++) {
+		kbd_fd[i] = -1;
+	}
+	
+	for(i=0; i<32; i++ )
+	{
+		snprintf(device, sizeof(device), "/dev/input/event%i", i);
+		if(access(device, R_OK)) continue;
+		fd = open(device, O_RDONLY);
+		if(fd<0)continue;
+
+		type=0;
+		name[0] = 0;
+
+        ioctl(fd, EVIOCGNAME(sizeof(name)), name);
+		ioctl(fd, EVIOCGBIT(0, sizeof(mask)), mask);
+		close(fd);
+
+		for(j=0; j<EV_MAX; j++)
+		{
+			if(mask[(j)/8] & (1 << ((j)%8)))
+			{
+				switch(j)
+				{
+					case EV_KEY: type |= 1; break;
+					case EV_REP: type |= 2;	break;
+					case EV_REL: type |= 4; break;
+					//case EV_LED: type |= 8; break;
+				}
+			}
+		}
+		if(type==3)
+		{
+			if (SDL_strncmp(name, "dreambox front panel", 20) != 0)
+			{
+				if((kbd_fd[++kbd_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+
+				else {
+					panel = kbd_fd[kbd_index];
+#ifdef DEBUG_KEYBOARD
+					fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+				}
+			}
+			else if (SDL_strncmp(name, "dreambox remote control", 23) != 0)
+			{
+				if((kbd_fd[++kbd_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+				else {
+					rc = kbd_fd[kbd_index];
+#ifdef DEBUG_KEYBOARD
+					fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+				}
+			}
+			else if (SDL_strncmp(name, "dreambox advanced remote control", 32) != 0 )
+			{
+				if((kbd_fd[++kbd_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+				else {
+					arc = kbd_fd[kbd_index];
+#ifdef DEBUG_KEYBOARD
+					fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+				}
+			}
+			else if (SDL_strncmp(name, "dreambox ir keyboard", 20) != 0)
+			{
+				if((kbd_fd[++kbd_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+
+				else {
+					kbd = kbd_fd[kbd_index];
+#ifdef DEBUG_KEYBOARD
+					fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+				}
+			}
+			else
+			{
+				if((kbd_fd[++kbd_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+#ifdef DEBUG_KEYBOARD
+				else {
+					fprintf(stderr,"'USB: %s' found %s\n",name,device);
+				}
+#endif
+			}
+		}
+	}
+#ifdef DEBUG_KEYBOARD
+	for (i = 0; i < 32; i++) {
+		if (kbd_fd[i] > -1) {
+			fprintf(stderr,"kbd_fd[%d] = %d\n",i,kbd_fd[i]);
+		}
+	}
+#endif /* DEBUG_KEYBOARD */
+
+ 	return(kbd_fd[0]);
+}
+
+void BCMFB_CloseMouse(_THIS)
+{
+	int i;
+	for (i = 0; i < 32; i++) {
+		if (mice_fd[i] != -1) {
+			close(mice_fd[i]);
+		}
+		mice_fd[i] = -1;
+	}
+	m_index = -1;
+}
+
+int BCMFB_OpenMouse(_THIS)
+{
+	unsigned char mask[EV_MAX/8 + 1];
+	char device[64], name[128];
+	int type=0;
+	int fd, i, j;
+	
+	for(i=0; i<32; i++ )
+	{
+		snprintf(device, sizeof(device), "/dev/input/event%i", i);
+		if(access(device, R_OK)) continue;
+		fd = open(device, O_RDONLY);
+		if(fd<0)continue;
+
+		type=0;
+		name[0] = 0;
+
+		ioctl(fd, EVIOCGNAME(sizeof(name)), name);
+		ioctl(fd, EVIOCGBIT(0, sizeof(mask)), mask);
+		close(fd);
+
+		for(j=0; j<EV_MAX; j++)
+		{
+			if(mask[(j)/8] & (1 << ((j)%8)))
+			{
+				switch(j)
+				{
+						case EV_KEY: type |= 1; break;
+						case EV_REP: type |= 2;	break;
+						case EV_REL: type |= 4; break;
+				}
+			}
+		}
+		if(type==5)
+		{
+			if(SDL_strncmp(name, "dreambox ir mouse", 17) != 0 )
+			{
+				if((mice_fd[++m_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+						exit(0);
+				}
+#ifdef DEBUG_MOUSE
+				else fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+			}
+			else {
+				if((mice_fd[++m_index]=open(device, O_RDONLY|O_NONBLOCK)) == -1)
+				{
+					SDL_SetError("Unable to open %s",name);
+					exit(0);
+				}
+#ifdef DEBUG_MOUSE
+				else fprintf(stderr,"'%s' found %s\n",name,device);
+#endif
+			}
+		}
+	}
+#ifdef DEBUG_MOUSE
+	for (i = 0; i < 32; i++) {
+		if (mice_fd[i] > -1) {
+			fprintf(stderr,"mice_fd[%d] = %d\n",i,mice_fd[i]);
+		}
+	}
+#endif /* DEBUG_MOUSE */
+	return(mice_fd[0]);
+}
+
+static void handle_mouse(_THIS, int m_fd)
+{
+	if (m_fd < 0)
+		return;
+	
+	struct input_event buffer[32];
+	int i;
+	int n = 0;
+	int m_x = 0;
+	int m_y = 0;
+	Uint8 button;
+	Uint8 state;
+
+	while(1) {
+		int bytesRead = read(m_fd, (char *)(buffer) + n, sizeof(buffer) - n);
+		if (bytesRead == 0) {
+			fprintf(stderr,"Warning: Got EOF from the input device.\n");
+			return;
+		}
+		if (bytesRead == -1) {
+			if (errno != EAGAIN)
+				fprintf(stderr,"Warning: Could not read from input device: %s\n", strerror(errno));
+			break;
+		}
+
+		n += bytesRead;
+		if (n % sizeof(buffer[0]) == 0)
+			break;
+	}
+	n /= sizeof(buffer[0]);
+
+	for (i = 0; i < n; ++i) {
+		struct input_event *data = &buffer[i];
+
+		SDL_bool unknown = SDL_FALSE;
+		if (data->type == EV_ABS) {
+			if (data->code == ABS_X) {
+				m_x = (signed char)data->value;
+			} 
+			else if (data->code == ABS_Y) {
+				m_y = (signed char)data->value;
+			} 
+			else {
+				unknown = SDL_TRUE;
+			}
+		} 
+		else if (data->type == EV_REL) {
+			if (data->code == REL_X) {
+				m_x += (signed char)data->value;
+			} 
+			else if (data->code == REL_Y) {
+				m_y += (signed char)data->value;
+			} 
+			else {
+				unknown = SDL_TRUE;
+			}
+		} 
+		else if (data->type == EV_KEY && data->code == BTN_TOUCH) {
+			button = SDL_BUTTON_RIGHT;
+			state = SDL_PRESSED;
+#ifdef DEBUG_MOUSE
+			fprintf(stderr,"HID mouse: BTN_TOUCH\n");
+#endif
+		} 
+		else if (data->type == EV_KEY) {
+			switch (data->code) {
+			case BTN_LEFT:
+				button = SDL_BUTTON_LEFT;
+#ifdef DEBUG_MOUSE		
+				fprintf(stderr,"HID mouse: BTN_LEFT\n");
+#endif
+				break;
+			case BTN_MIDDLE:
+				button = SDL_BUTTON_MIDDLE;
+#ifdef DEBUG_MOUSE
+				fprintf(stderr,"HID mouse: BTN_MIDDLE\n");
+#endif
+				break;
+			case BTN_RIGHT:
+				button = SDL_BUTTON_RIGHT;
+#ifdef DEBUG_MOUSE
+				fprintf(stderr,"HID mouse: BTN_RIGHT\n");
+#endif
+				break;
+			case BTN_WHEEL:
+				button = 0;
+#ifdef DEBUG_MOUSE
+				fprintf(stderr,"HID mouse: BTN_WHEEL\n");
+#endif
+				break;
+			default:
+				button = 0;
+#ifdef DEBUG_MOUSE
+				fprintf(stderr,"HID mouse: Unknown BTN event\n");
+#endif
+			}
+
+			if (data->value) {
+				state = SDL_PRESSED;
+			} 
+			else {
+				state = SDL_RELEASED;
+			}
+		} 
+		else if (data->type == EV_SYN && data->code == SYN_REPORT) {
+			posted += SDL_PrivateMouseMotion(0, 1, m_x, m_y);
+			if (button > 0) {
+				posted += SDL_PrivateMouseButton(state, button, 0, 0);
+			}
+			
+#ifdef DEBUG_MOUSE
+			fprintf(stderr,"HID dream mouse: x=%d y=%d button=%d\n",m_x, m_y, button);
+#endif
+		} 
+		else if (data->type == EV_MSC && data->code == MSC_SCAN) {
+			// kernel encountered an unmapped key - just ignore it
+			continue;
+		} 
+		else {
+			unknown = SDL_TRUE;
+		}
+		if (unknown) {
+			fprintf(stderr,"Warning: unknown mouse event type=%x, code=%x, value=%x", data->type, data->code, data->value);
+		}
+	}
+	return;
+}
+
+static void handle_keyboard(_THIS, int k_fd)
+{
+	if (k_fd < 0) {
+		return;
+	}
+	int x, pressed;
+	int caps=0;
+	unsigned short code = 0xee;
+	struct input_event ev;
+	
+	SDL_keysym keysym;
+	SDLMod mode = KMOD_NONE;
+	
+	x = read( k_fd, &ev, sizeof(struct input_event) );
+	if(x > 0)
+	{
+		SDL_memcpy(&code,&ev.code,sizeof(ev.code));
+		if ((code == KEY_LEFTSHIFT || code == KEY_RIGHTSHIFT) && ev.value == 1 && ev.type == EV_KEY)
+			mode=KMOD_SHIFT;
+		if ((code == KEY_LEFTSHIFT || code == KEY_RIGHTSHIFT) && ev.value == 0 && ev.type == EV_KEY)
+			mode=KMOD_NONE;
+		if ((code == KEY_LEFTCTRL || code == KEY_RIGHTCTRL) && ev.value == 1 && ev.type == EV_KEY)
+			mode=KMOD_CTRL;
+		if ((code == KEY_LEFTCTRL || code == KEY_RIGHTCTRL) && ev.value == 0 && ev.type == EV_KEY)
+			mode=KMOD_NONE;
+		if ((code == KEY_LEFTALT) && ev.value == 1 && ev.type == EV_KEY)
+			mode=KMOD_LALT;
+		if ((code == KEY_LEFTALT) && ev.value == 0 && ev.type == EV_KEY)
+			mode=KMOD_NONE;
+		if ((code == KEY_RIGHTALT) && ev.value == 1 && ev.type == EV_KEY)
+			mode=KMOD_RALT;
+		if ((code == KEY_RIGHTALT) && ev.value == 0 && ev.type == EV_KEY)
+			mode=KMOD_NONE;
+		if ((code == KEY_CAPSLOCK) && ev.value == 1 && ev.type == EV_KEY)
+		{
+			if (caps == 1) {caps=0;} else {caps=1;}
+		}
+
+		if (mode == KMOD_NONE && caps == 1) {mode=KMOD_RSHIFT;}
+		
+		if ((code == KEY_TV) && ev.value == 1 && ev.type == EV_KEY) {exit(0);}
+		
+		if ((ev.value == 0 || ev.value == 1 || ev.value == 2) && ev.type == EV_KEY)
+		{
+			if (k_fd == kbd) {
+				keysym.sym = KeyTranslate(code,1);
+#ifdef DEBUG_KEYBOARD
+				fprintf(stderr,"HID dreambox ir keyboard\n");
+#endif
+			}
+			else if (k_fd == arc) {
+				keysym.sym = KeyTranslate(code,0);
+#ifdef DEBUG_KEYBOARD
+				fprintf(stderr,"HID dreambox advanced remote control\n");
+#endif
+			}
+			else if (k_fd == rc) {
+				keysym.sym = KeyTranslate(code,0);
+#ifdef DEBUG_KEYBOARD
+				fprintf(stderr,"HID dreambox remote control\n");
+#endif
+			}
+			else {
+				keysym.sym = KeyTranslate(code,0);
+#ifdef DEBUG_KEYBOARD
+				fprintf(stderr,"HID kbd code %d\n",code);
+#endif
+			}
+			if (keysym.sym == SDLK_UNKNOWN) {
+#ifdef DEBUG_KEYBOARD
+				fprintf(stderr,"SDLKey: SDLK_UNKNOWN\n");
+#endif
+				return;
+			}
+			fprintf(stderr,"SDLKey: %d\n", keysym.sym);
+			if ( ev.value > 0) {
+				pressed = SDL_PRESSED;
+			}
+			else {
+				pressed = SDL_RELEASED;
+			}
+			
+			keysym.scancode = K(KT_ASCII,13);
+			keysym.mod = mode;
+			keysym.unicode = 0;
+			posted += SDL_PrivateKeyboard(pressed, &keysym);
+		}
+		if (mode == KMOD_RSHIFT && caps == 1) {mode=KMOD_NONE;}
+			ev.value=-1;
+	}
+}
+
+void BCMFB_PumpEvents(_THIS)
+{
+	fd_set fdset;
+	int max_fd, i;
+	static struct timeval zero;
+
+	do {
+		posted = 0;
+		FD_ZERO(&fdset);
+		max_fd = 0;
+		for( i = 0; i <= kbd_index; i++) {
+			if ( kbd_fd[i] >= 0 ) {
+				FD_SET(kbd_fd[i], &fdset);
+				if ( max_fd < kbd_fd[i] ) {
+					max_fd = kbd_fd[i];
+				}
+			}
+		}
+		for( i = 0; i <= m_index; i++) {
+			if ( mice_fd[i] >= 0 ) {
+				FD_SET(mice_fd[i], &fdset);
+				if ( max_fd < mice_fd[i] ) {
+					max_fd = mice_fd[i];
+				}
+			}
+		}
+		if ( select(max_fd+1, &fdset, NULL, NULL, &zero) > 0 ) {
+			for( i = 0; i <= kbd_index; i++) {
+				if ( kbd_fd[i] >= 0 ) {
+					if ( FD_ISSET(kbd_fd[i], &fdset) ) {
+						handle_keyboard(this, kbd_fd[i]);
+					}
+				}
+			}
+			for( i = 0; i <= m_index; i++) {
+				if ( mice_fd[i] >= 0 ) {
+					if ( FD_ISSET(mice_fd[i], &fdset) ) {
+						handle_mouse(this, mice_fd[i]);
+					}
+				}
+			}
+		}
+	} while ( posted );
+}
+
+static SDLKey KeyTranslate(unsigned short code, int type) {
+	
+	// dreambox keyboard
+	if (type == 1) {
+		switch (code) {
+			case KEY_F1:		return SDLK_CARET;
+			case KEY_F2:		return SDLK_F1;
+			case KEY_F3:		return SDLK_F2;
+			case KEY_BACK:		return SDLK_F3;
+			case KEY_FORWARD:	return SDLK_F4;
+			case KEY_F6:		return SDLK_F5;
+			case KEY_F7:		return SDLK_F6;
+			case KEY_F8:		return SDLK_F7;
+			case KEY_RECORD:	return SDLK_F8;
+			case KEY_STOP:		return SDLK_F9;
+			case KEY_PAUSE:		return SDLK_F10;
+			case KEY_PREVIOUSSONG:	return SDLK_F11;
+			case KEY_PLAY:		return SDLK_F12;
+			case KEY_FASTFORWARD:	return SDLK_SYSREQ;;
+			case KEY_NEXTSONG:	return SDLK_PAUSE;
+		}
+	}
+	// default keyboard
+	switch (code) {
+		case KEY_0:		return SDLK_0;
+		case KEY_1:		return SDLK_1;
+		case KEY_2:		return SDLK_2;
+		case KEY_3:		return SDLK_3;
+		case KEY_4:		return SDLK_4;
+		case KEY_5:		return SDLK_5;
+		case KEY_6:		return SDLK_6;
+		case KEY_7:		return SDLK_7;
+		case KEY_8:		return SDLK_8;
+		case KEY_9:		return SDLK_9;
+		case KEY_A:		return SDLK_a;
+		case KEY_B:		return SDLK_b;
+		case KEY_C:		return SDLK_c;
+		case KEY_D:		return SDLK_d;
+		case KEY_E:		return SDLK_e;
+		case KEY_F:		return SDLK_f;
+		case KEY_G:		return SDLK_g;
+		case KEY_H:		return SDLK_h;
+		case KEY_I:		return SDLK_i;
+		case KEY_J:		return SDLK_j;
+		case KEY_K:		return SDLK_k;
+		case KEY_L:		return SDLK_l;
+		case KEY_M:		return SDLK_m;
+		case KEY_N:		return SDLK_n;
+		case KEY_O:		return SDLK_o;
+		case KEY_P:		return SDLK_p;
+		case KEY_Q:		return SDLK_q;
+		case KEY_R:		return SDLK_r;
+		case KEY_S:		return SDLK_s;
+		case KEY_T:		return SDLK_t;
+		case KEY_U:		return SDLK_u;
+		case KEY_V:		return SDLK_v;
+		case KEY_W:		return SDLK_w;
+		case KEY_X:		return SDLK_x;
+		case KEY_Y:		return SDLK_y;
+		case KEY_Z:		return SDLK_z;
+		case KEY_APOSTROPHE:	return SDLK_QUOTEDBL;
+		case KEY_SEMICOLON:	return SDLK_SEMICOLON;
+		case KEY_LEFTBRACE:	return SDLK_LEFTBRACKET;
+
+		case KEY_MINUS:		return SDLK_MINUS;
+		case KEY_EQUAL:		return SDLK_EQUALS;
+		case KEY_SLASH:		return SDLK_SLASH;
+		case KEY_BACKSPACE:	return SDLK_BACKSPACE;
+
+		case KEY_TAB:		return SDLK_TAB;
+		case KEY_RIGHTBRACE:	return SDLK_RIGHTBRACKET;
+		case KEY_BACKSLASH:	return SDLK_BACKSLASH;
+
+		case KEY_OK:
+		case KEY_ENTER:		return SDLK_RETURN;
+
+		case KEY_COMMA:		return SDLK_COMMA;
+		case KEY_DOT:		return SDLK_PERIOD;
+
+		case KEY_GRAVE:		return SDLK_CARET;
+
+		case KEY_LEFT:		return SDLK_LEFT;
+		case KEY_RIGHT:		return SDLK_RIGHT;
+		case KEY_UP:		return SDLK_UP;
+		case KEY_DOWN:		return SDLK_DOWN;
+
+		case KEY_102ND:		return SDLK_LESS;
+
+		case KEY_F1:		return SDLK_F1;
+		case KEY_F2:		return SDLK_F2;
+		case KEY_F3:		return SDLK_F3;
+		case KEY_F4:		return SDLK_F4;
+		case KEY_F5:		return SDLK_F5;
+		case KEY_F6:		return SDLK_F6;
+		case KEY_F7:		return SDLK_F7;
+		case KEY_F8:		return SDLK_F8;
+		case KEY_F9:		return SDLK_F9;
+		case KEY_F10:		return SDLK_F10;
+		case KEY_F11:		return SDLK_F11;
+		case KEY_F12:		return SDLK_F12;
+		case KEY_F13:		return SDLK_F13;
+		case KEY_F14:		return SDLK_F14;
+		case KEY_F15:		return SDLK_F15;
+		
+		// Dream F4, F5, ...
+		case KEY_BACK:		return SDLK_F4;
+		case KEY_FORWARD:	return SDLK_F5;
+		
+		case KEY_RECORD:	return SDLK_F9;
+		case KEY_PAUSE:		return SDLK_PAUSE;
+#if 0
+		case KEY_:		return SDLK_ASTERISK;
+		case KEY_:		return SDLK_PLUS;
+		case KEY_STOP:		return SDLK_UNKNOWN;
+		case KEY_PREVIOUSSONG:	return SDLK_UNKNOWN;
+		case KEY_REWIND:	return SDLK_UNKNOWN;
+		case KEY_PLAY:		return SDLK_UNKNOWN;
+		case KEY_FASTFORWARD:	return SDLK_UNKNOWN;
+		case KEY_NEXTSONG:	return SDLK_UNKNOWN;
+		
+		case KEY_MUTE:		return SDLK_UNKNOWN;
+		case KEY_VOLUMEUP:	return SDLK_UNKNOWN;
+		case KEY_VOLUMEDOWN:	return SDLK_UNKNOWN;
+		
+		case KEY_RED:		return SDLK_UNKNOWN;
+		case KEY_GREEN:		return SDLK_UNKNOWN;
+		case KEY_YELLOW:	return SDLK_UNKNOWN;
+		case KEY_BLUE:		return SDLK_UNKNOWN;
+		
+		case KEY_INFO:		return SDLK_UNKNOWN;
+		case KEY_MENU:		return SDLK_UNKNOWN;
+		case KEY_VIDEO:		return SDLK_UNKNOWN;
+		case KEY_AUDIO:		return SDLK_UNKNOWN;
+		
+		case KEY_COMPOSE:	return SDLK_UNKNOWN;
+		case KEY_PROG1:		return SDLK_UNKNOWN;
+#endif
+		case KEY_CHANNELUP:	return SDLK_PAGEUP;
+		case KEY_CHANNELDOWN:	return SDLK_PAGEDOWN;
+		
+		case KEY_TV:		return SDLK_ESCAPE;
+		case KEY_RADIO:		return SDLK_ESCAPE;
+
+		case KEY_SPACE:		return SDLK_SPACE;
+		case KEY_DELETE:	return SDLK_DELETE;
+		case KEY_ESC:		return SDLK_ESCAPE;
+		case KEY_INSERT:	return SDLK_INSERT;
+			
+		case KEY_HELP:		return SDLK_HELP;
+		case KEY_HOME:		return SDLK_HOME;
+		case KEY_MENU:		return SDLK_MENU;
+		case KEY_EXIT:		return SDLK_ESCAPE;
+		case KEY_END:		return SDLK_END;
+		
+		case KEY_NUMLOCK:	return SDLK_NUMLOCK;
+		case KEY_CAPSLOCK:	return SDLK_CAPSLOCK;
+		case KEY_SCROLLLOCK:	return SDLK_SCROLLOCK;
+		case KEY_RIGHTSHIFT:	return SDLK_RSHIFT;
+		case KEY_LEFTSHIFT:	return SDLK_LSHIFT;
+		case KEY_RIGHTCTRL:	return SDLK_RCTRL;
+		case KEY_LEFTCTRL:	return SDLK_LCTRL;
+		case KEY_RIGHTALT:	return SDLK_RALT;
+		case KEY_LEFTALT:	return SDLK_LALT;
+		case KEY_RIGHTMETA:	return SDLK_RMETA;
+		case KEY_LEFTMETA:	return SDLK_LMETA;
+// SDLK_PRINT;
+		case KEY_SYSRQ:		return SDLK_SYSREQ;
+// SDLK_BREAK;
+		case KEY_POWER:		return SDLK_POWER;
+// SDLK_EURO;
+		
+		default:		return SDLK_UNKNOWN;
+	}
+}
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbevents_c.h SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbevents_c.h
--- SDL-1.2.15/src/video/bcmfb/SDL_fbevents_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbevents_c.h	2016-02-11 23:49:17.000000000 +0100
@@ -0,0 +1,24 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+#include "SDL_fbvideo.h"
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern int BCMFB_OpenKeyboard(_THIS);
+extern void BCMFB_CloseKeyboard(_THIS);
+extern int BCMFB_OpenMouse(_THIS);
+extern void BCMFB_CloseMouse(_THIS);
+extern int BCMFB_EnterGraphicsMode(_THIS);
+extern int BCMFB_InGraphicsMode(_THIS);
+extern void BCMFB_LeaveGraphicsMode(_THIS);
+
+extern void BCMFB_InitOSKeymap(_THIS);
+extern void BCMFB_PumpEvents(_THIS);
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbmouse.c SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbmouse.c
--- SDL-1.2.15/src/video/bcmfb/SDL_fbmouse.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbmouse.c	2016-02-11 23:49:17.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_fbvideo.h"
+#include "SDL_fbmouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+	int unused;
+};
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbmouse_c.h SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbmouse_c.h
--- SDL-1.2.15/src/video/bcmfb/SDL_fbmouse_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbmouse_c.h	2016-02-11 23:49:17.000000000 +0100
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_fbvideo.h"
+
+/* Functions to be exported */
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbvideo.c SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbvideo.c
--- SDL-1.2.15/src/video/bcmfb/SDL_fbvideo.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbvideo.c	2016-02-16 14:56:41.000000000 +0100
@@ -0,0 +1,1729 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+/* Framebuffer console based SDL video driver implementation.
+*/
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#ifndef HAVE_GETPAGESIZE 
+#include <asm/page.h>		/* For definition of PAGE_SIZE */
+#endif
+
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_fbvideo.h"
+#include "SDL_fbmouse_c.h"
+#include "SDL_fbevents_c.h"
+#include "SDL_bcmfb.h"
+
+#define BCMFB_DEBUG
+#define BCMFB_ACCEL_DEBUG
+
+#ifndef FBIO_BLIT
+#define FBIO_SET_MANUAL_BLIT _IOW('F', 0x21, __u8)
+#define FBIO_BLIT 0x22
+#endif
+
+/* A list of video resolutions that we query for (sorted largest to smallest) */
+static const SDL_Rect checkres[] = {
+	{  0, 0,  1920, 1080 },		// bcmfb
+	{  0, 0,  1408, 1056 },		// bcmfb
+	{  0, 0,  1280, 1024 },		// bcmfb
+	{  0, 0,  1280,  720 },		// bcmfb
+	{  0, 0,  1152,  864 },		// bcmfb
+	{  0, 0,  1024,  768 },		// bcmfb
+	{  0, 0,  960,   720 },		// bcmfb
+	{  0, 0,  800,   600 },		// bcmfb
+	{  0, 0,  768,   576 },		// bcmfb
+	{  0, 0,  720,   576 },		// bcmfb PAL
+	{  0, 0,  640,   480 },		// bcmfb 16 bpp: 0x111, or 273
+	{  0, 0,  640,   400 },		// bcmfb  8 bpp: 0x100, or 256
+	{  0, 0,  512,   384 },		// bcmfb
+	{  0, 0,  320,   240 },		// bcmfb
+	{  0, 0,  320,   200 }
+};
+static const struct {
+	int xres;
+	int yres;
+	int pixclock;
+	int left;
+	int right;
+	int upper;
+	int lower;
+	int hslen;
+	int vslen;
+	int sync;
+	int vmode;
+} BCMFB_timings[] = {
+	// bcmfb U:320x200i-341 mode "320x200-170"
+	{  320,  200, 60440,  32, 32, 20,  4,  48,  1, 0, 2 },	/* 170 Hz */
+	// bcmfb U:320x200d-69 mode "320x200-140"
+	{  320,  200, 79440,  16, 16, 20,  4,  48,  1, 0, 2 },	/* 140 Hz */
+	// bcmfb 320x240d-75 
+	{  320,  240, 63492,  16, 16, 16,  4,  48,  2, 0, 0 },	/* 75 Hz */
+	// bcmfb U:512x384p-77 mode "512x384-78"
+	{  512,  384, 49603,  48, 16, 16,  1,  64,  3, 0, 0 },	/* 78 Hz */
+	// bcmfb U:640x400i-185 mode "640x400-92"
+	{  640,  400, 28272,  48, 32, 17, 22, 128, 12, 0, 0 },	/* 92 Hz */
+	// bcmfb U:640x480p-75 mode "640x480-75"
+	{  640,  480, 31747, 120, 16, 16,  1,  64,  3, 0, 0 },	/* 75 Hz */
+	// bcmfb U:720x576i-170 mode "720x576-85"
+	{  720,  576, 20000,  64, 64, 32, 32,  64,  2, 0, 0 },	/* 85 Hz */
+	// bcmfb U:768x576p-59 mode "768x576-60"
+	{  768,  576, 26101, 144, 16, 28, 6,  112,  4, 0, 0 },	/* 60 Hz */
+	// bcmfb U:800x600p-72 mode "800x600-72"
+	{  800,  600, 20000,  64, 56, 23, 37, 120,  6, 0, 0 },	/* 72 Hz */
+	// bcmfb U:960x720p-59 mode "960x720-60"
+	{  960,  720, 17686, 144, 24, 28, 8,  122,  4, 0, 0 },	/* 60 Hz */
+	// bcmfb U:1024x768p-70 mode "1024x768-70"
+	{  1024, 768, 13333, 144, 24, 29, 3,  136,  6, 0, 0 },	/* 70 Hz */
+	// bcmfb U:1152x864p-59 mode "1152x864-60"
+	{  1152, 864, 12286, 192, 32, 30, 4,  128,  4, 0, 0 },	/* 60 Hz */
+	// bcmfb U:1280x720i-86 mode "1280x720-43"
+	{  1280, 720, 20000, 64,  64, 32, 32,  64,  2, 0, 0 },	/* 43 Hz */
+	// bcmfb U:1280x1024p-59 mode "1280x1024-60"
+	{  1280, 1024, 9369, 224, 32, 32, 4,  136,  4, 0, 0 },	/* 60 Hz */
+	// bcmfb U:1408x1056p-59 mode mode "1408x1056-60"
+	{  1408, 1056, 8214, 256, 40, 32, 5,  144,  5, 0, 0 },	/* 60 Hz */
+	// bcmfb U:1920x1080i-41 mode "1920x1080-21"
+	{  1920, 1080, 20000, 64, 64, 32, 32,  64,  2, 0, 0 }	/* 21 Hz */
+};
+enum {
+	BCMFB_ROTATE_NONE = 0,
+	BCMFB_ROTATE_CCW = 90,
+	BCMFB_ROTATE_UD = 180,
+	BCMFB_ROTATE_CW = 270
+};
+
+#define min(a,b) ((a)<(b)?(a):(b))
+
+/* Initialization/Query functions */
+static int BCMFB_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **BCMFB_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+static SDL_Surface *BCMFB_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
+static int BCMFB_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors);
+static void BCMFB_VideoQuit(_THIS);
+
+/* Hardware surface functions */
+static int BCMFB_InitHWSurfaces(_THIS, SDL_Surface *screen, char *base, int size);
+static void BCMFB_FreeHWSurfaces(_THIS);
+static int BCMFB_AllocHWSurface(_THIS, SDL_Surface *surface);
+static int BCMFB_LockHWSurface(_THIS, SDL_Surface *surface);
+static void BCMFB_UnlockHWSurface(_THIS, SDL_Surface *surface);
+static void BCMFB_FreeHWSurface(_THIS, SDL_Surface *surface);
+static void BCMFB_WaitVBL(_THIS);
+static void BCMFB_WaitIdle(_THIS);
+static int BCMFB_FlipHWSurface(_THIS, SDL_Surface *surface);
+
+/* Internal palette functions */
+static void BCMFB_SavePalette(_THIS, struct fb_fix_screeninfo *finfo,
+                                  struct fb_var_screeninfo *vinfo);
+static void BCMFB_RestorePalette(_THIS);
+
+/* Shadow buffer functions */
+static BCMFB_bitBlit BCMFB_blit16;
+static BCMFB_bitBlit BCMFB_blit16blocked;
+
+static int SDL_getpagesize(void)
+{
+#ifdef HAVE_GETPAGESIZE
+	return getpagesize();
+#elif defined(PAGE_SIZE)
+	return PAGE_SIZE;
+#else
+#error Can not determine system page size.
+	return 4096;  /* this is what it USED to be in Linux... */
+#endif
+}
+
+/* Small wrapper for mmap() so we can play nicely with no-mmu hosts
+ * (non-mmu hosts disallow the MAP_SHARED flag) */
+
+static void *do_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
+{
+	void *ret;
+	ret = mmap(start, length, prot, flags, fd, offset);
+	if ( ret == (char *)-1 && (flags & MAP_SHARED) ) {
+		ret = mmap(start, length, prot,
+		           (flags & ~MAP_SHARED) | MAP_PRIVATE, fd, offset);
+	}
+	return ret;
+}
+
+/* FB driver bootstrap functions */
+
+static int BCMFB_Available(void)
+{
+	int console = -1;
+	/* Added check for /fb/0 (devfs) */
+	/* but - use environment variable first... if it fails, still check defaults */
+	int idx = 0;
+	const char *SDL_fbdevs[4] = { NULL, "/dev/fb0", "/dev/fb/0", NULL };
+
+	SDL_fbdevs[0] = SDL_getenv("SDL_FBDEV");
+	if( !SDL_fbdevs[0] )
+		idx++;
+	for( ; SDL_fbdevs[idx]; idx++ )
+	{
+		console = open(SDL_fbdevs[idx], O_RDWR, 0);
+		if ( console >= 0 ) {
+			close(console);
+			break;
+		}
+	}
+	return(console >= 0);
+}
+
+static void BCMFB_DeleteDevice(SDL_VideoDevice *device)
+{
+	SDL_free(device->hidden);
+	SDL_free(device);
+}
+
+static SDL_VideoDevice *BCMFB_CreateDevice(int devindex)
+{
+	int i;
+	SDL_VideoDevice *this;
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( this ) {
+		SDL_memset(this, 0, (sizeof *this));
+		this->hidden = (struct SDL_PrivateVideoData *)
+				SDL_malloc((sizeof *this->hidden));
+	}
+	if ( (this == NULL) || (this->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( this ) {
+			SDL_free(this);
+		}
+		return(0);
+	}
+	SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+	for (i = 0; i < 32; i++) {
+		if (kbd_fd[i] != -1) {
+			close(kbd_fd[i]);
+		}
+		kbd_fd[i] = -1;
+	}
+
+	for (i = 0; i < 32; i++) {
+		mice_fd[i] = -1;
+	}
+	
+	m_index = -1;
+	kbd_index = -1;
+	panel = -1;
+	kbd = -1;
+	arc = -1;
+	rc = -1;
+	
+	wait_vbl = BCMFB_WaitVBL;
+	wait_idle = BCMFB_WaitIdle;
+
+	/* Set the function pointers */
+	this->VideoInit = BCMFB_VideoInit;
+	this->ListModes = BCMFB_ListModes;
+	this->SetVideoMode = BCMFB_SetVideoMode;
+	this->SetColors = BCMFB_SetColors;
+	this->UpdateRects = NULL;
+	this->VideoQuit = BCMFB_VideoQuit;
+	this->AllocHWSurface = BCMFB_AllocHWSurface;
+	this->CheckHWBlit = NULL;
+	this->FillHWRect = NULL;
+	this->SetHWColorKey = NULL;
+	this->SetHWAlpha = NULL;
+	this->LockHWSurface = BCMFB_LockHWSurface;
+	this->UnlockHWSurface = BCMFB_UnlockHWSurface;
+	this->FlipHWSurface = BCMFB_FlipHWSurface;
+	this->FreeHWSurface = BCMFB_FreeHWSurface;
+	this->SetCaption = NULL;
+	this->SetIcon = NULL;
+	this->IconifyWindow = NULL;
+	this->GrabInput = NULL;
+	this->GetWMInfo = NULL;
+	this->InitOSKeymap = BCMFB_InitOSKeymap;
+	this->PumpEvents = BCMFB_PumpEvents;
+
+	this->free = BCMFB_DeleteDevice;
+
+	return this;
+}
+
+VideoBootStrap BCMFB_bootstrap = {
+	"bcmfb", "BCMFB Framebuffer Console",
+	BCMFB_Available, BCMFB_CreateDevice
+};
+
+#define BCMFB_MODES_DB	"/etc/bcmfb.modes"
+
+static int read_bcmfb_modes_line(FILE*f, char* line, int length)
+{
+	int blank;
+	char* c;
+	int i;
+	
+	blank=0;
+	/* find a relevant line */
+	do
+	{
+		if (!fgets(line,length,f))
+			return 0;
+		c=line;
+		while(((*c=='\t')||(*c==' '))&&(*c!=0))
+			c++;
+		
+		if ((*c=='\n')||(*c=='#')||(*c==0))
+			blank=1;
+		else
+			blank=0;
+	}
+	while(blank);
+	/* remove whitespace at the begining of the string */
+	i=0;
+	do
+	{
+		line[i]=c[i];
+		i++;
+	}
+	while(c[i]!=0);
+	return 1;
+}
+
+static int read_bcmfb_conf_mode(FILE *f, struct fb_var_screeninfo *vinfo)
+{
+	char line[1024];
+	char option[256];
+
+	/* Find a "geometry" */
+	do {
+		if (read_bcmfb_modes_line(f, line, sizeof(line))==0)
+			return 0;
+		if (SDL_strncmp(line,"geometry",8)==0)
+			break;
+	}
+	while(1);
+
+	SDL_sscanf(line, "geometry %d %d %d %d %d", &vinfo->xres, &vinfo->yres, 
+			&vinfo->xres_virtual, &vinfo->yres_virtual, &vinfo->bits_per_pixel);
+	if (read_bcmfb_modes_line(f, line, sizeof(line))==0)
+		return 0;
+			
+	SDL_sscanf(line, "timings %d %d %d %d %d %d %d", &vinfo->pixclock, 
+			&vinfo->left_margin, &vinfo->right_margin, &vinfo->upper_margin, 
+			&vinfo->lower_margin, &vinfo->hsync_len, &vinfo->vsync_len);
+		
+	vinfo->sync=0;
+	vinfo->vmode=FB_VMODE_NONINTERLACED;
+				
+	/* Parse misc options */
+	do {
+		if (read_bcmfb_modes_line(f, line, sizeof(line))==0)
+			return 0;
+
+		if (SDL_strncmp(line,"hsync",5)==0) {
+			SDL_sscanf(line,"hsync %s",option);
+			if (SDL_strncmp(option,"high",4)==0)
+				vinfo->sync |= FB_SYNC_HOR_HIGH_ACT;
+		}
+		else if (SDL_strncmp(line,"vsync",5)==0) {
+			SDL_sscanf(line,"vsync %s",option);
+			if (SDL_strncmp(option,"high",4)==0)
+				vinfo->sync |= FB_SYNC_VERT_HIGH_ACT;
+		}
+		else if (SDL_strncmp(line,"csync",5)==0) {
+			SDL_sscanf(line,"csync %s",option);
+			if (SDL_strncmp(option,"high",4)==0)
+				vinfo->sync |= FB_SYNC_COMP_HIGH_ACT;
+		}
+		else if (SDL_strncmp(line,"extsync",5)==0) {
+			SDL_sscanf(line,"extsync %s",option);
+			if (SDL_strncmp(option,"true",4)==0)
+				vinfo->sync |= FB_SYNC_EXT;
+		}
+		else if (SDL_strncmp(line,"laced",5)==0) {
+			SDL_sscanf(line,"laced %s",option);
+			if (SDL_strncmp(option,"true",4)==0)
+				vinfo->vmode |= FB_VMODE_INTERLACED;
+		}
+		else if (SDL_strncmp(line,"double",6)==0) {
+			SDL_sscanf(line,"double %s",option);
+			if (SDL_strncmp(option,"true",4)==0)
+				vinfo->vmode |= FB_VMODE_DOUBLE;
+		}
+	}
+	while(SDL_strncmp(line,"endmode",7)!=0);
+
+	return 1;
+}
+
+static int BCMFB_CheckMode(_THIS, struct fb_var_screeninfo *vinfo,
+                        int index, unsigned int *w, unsigned int *h)
+{
+	int mode_okay;
+
+	mode_okay = 0;
+	vinfo->bits_per_pixel = (index+1)*8;
+	vinfo->xres = *w;
+	vinfo->xres_virtual = *w;
+	vinfo->yres = *h;
+	vinfo->yres_virtual = *h;
+	vinfo->activate = FB_ACTIVATE_TEST;
+	if ( ioctl(console_fd, FBIOPUT_VSCREENINFO, vinfo) == 0 ) {
+#ifdef BCMFB_DEBUG
+		fprintf(stderr, "Checked mode %dx%d at %d bpp, got mode %dx%d at %d bpp\n", *w, *h, (index+1)*8, vinfo->xres, vinfo->yres, vinfo->bits_per_pixel);
+#endif
+		if ( (((vinfo->bits_per_pixel+7)/8)-1) == index ) {
+			*w = vinfo->xres;
+			*h = vinfo->yres;
+			mode_okay = 1;
+		}
+	}
+	return mode_okay;
+}
+
+static int BCMFB_AddMode(_THIS, int index, unsigned int w, unsigned int h, int check_timings)
+{
+	SDL_Rect *mode;
+	int i;
+	int next_mode;
+
+	/* Check to see if we already have this mode */
+	if ( SDL_nummodes[index] > 0 ) {
+		mode = SDL_modelist[index][SDL_nummodes[index]-1];
+		if ( (mode->w == w) && (mode->h == h) ) {
+#ifdef BCMFB_DEBUG
+			fprintf(stderr, "We already have mode %dx%d at %d bytes per pixel\n", w, h, index+1);
+#endif
+			return(0);
+		}
+	}
+
+	/* Only allow a mode if we have a valid timing for it */
+	if ( check_timings ) {
+		int found_timing = 0;
+		for ( i=0; i<(sizeof(BCMFB_timings)/sizeof(BCMFB_timings[0])); ++i ) {
+			if ( (w == BCMFB_timings[i].xres) &&
+			     (h == BCMFB_timings[i].yres) && BCMFB_timings[i].pixclock ) {
+				found_timing = 1;
+				break;
+			}
+		}
+		if ( !found_timing ) {
+#ifdef BCMFB_DEBUG
+			fprintf(stderr, "No valid timing line for mode %dx%d\n", w, h);
+#endif
+			return(0);
+		}
+	}
+
+	/* Set up the new video mode rectangle */
+	mode = (SDL_Rect *)SDL_malloc(sizeof *mode);
+	if ( mode == NULL ) {
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	mode->x = 0;
+	mode->y = 0;
+	mode->w = w;
+	mode->h = h;
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "Adding mode %dx%d at %d bytes per pixel\n", w, h, index+1);
+#endif
+
+	/* Allocate the new list of modes, and fill in the new mode */
+	next_mode = SDL_nummodes[index];
+	SDL_modelist[index] = (SDL_Rect **)
+	       SDL_realloc(SDL_modelist[index], (1+next_mode+1)*sizeof(SDL_Rect *));
+	if ( SDL_modelist[index] == NULL ) {
+		SDL_OutOfMemory();
+		SDL_nummodes[index] = 0;
+		SDL_free(mode);
+		return(-1);
+	}
+	SDL_modelist[index][next_mode] = mode;
+	SDL_modelist[index][next_mode+1] = NULL;
+	SDL_nummodes[index]++;
+
+	return(0);
+}
+
+static int cmpmodes(const void *va, const void *vb)
+{
+    const SDL_Rect *a = *(const SDL_Rect**)va;
+    const SDL_Rect *b = *(const SDL_Rect**)vb;
+    if ( a->h == b->h )
+        return b->w - a->w;
+    else
+        return b->h - a->h;
+}
+
+static void BCMFB_SortModes(_THIS)
+{
+	int i;
+	for ( i=0; i<NUM_MODELISTS; ++i ) {
+		if ( SDL_nummodes[i] > 0 ) {
+			SDL_qsort(SDL_modelist[i], SDL_nummodes[i], sizeof *SDL_modelist[i], cmpmodes);
+		}
+	}
+}
+
+static int BCMFB_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	const int pagesize = SDL_getpagesize();
+	struct fb_fix_screeninfo finfo;
+	struct fb_var_screeninfo vinfo;
+	int i, j, current_index;
+	unsigned int current_w, current_h;
+	const char *SDL_fbdev;
+	const char *rotation;
+	const char *bcmfb_accel;
+	FILE *modesdb;
+
+	/* Initialize the library */
+	SDL_fbdev = SDL_getenv("SDL_FBDEV");
+	if ( SDL_fbdev == NULL ) {
+		SDL_fbdev = "/dev/fb0";
+	}
+	console_fd = open(SDL_fbdev, O_RDWR, 0);
+	if ( console_fd < 0 ) {
+		SDL_SetError("Unable to open %s", SDL_fbdev);
+		return(-1);
+	}
+
+#if !SDL_THREADS_DISABLED
+	/* Create the hardware surface lock mutex */
+	hw_lock = SDL_CreateMutex();
+	if ( hw_lock == NULL ) {
+		SDL_SetError("Unable to create lock mutex");
+		BCMFB_VideoQuit(this);
+		return(-1);
+	}
+#endif
+
+	/* Get the type of video hardware */
+	if ( ioctl(console_fd, FBIOGET_FSCREENINFO, &finfo) < 0 ) {
+		SDL_SetError("Couldn't get console hardware info");
+		BCMFB_VideoQuit(this);
+		return(-1);
+	}
+	switch (finfo.type) {
+		case FB_TYPE_PACKED_PIXELS:
+			/* Supported, no worries.. */
+			break;
+		default:
+			SDL_SetError("Unsupported console hardware");
+			BCMFB_VideoQuit(this);
+			return(-1);
+	}
+	switch (finfo.visual) {
+		case FB_VISUAL_TRUECOLOR:
+		case FB_VISUAL_PSEUDOCOLOR:
+		case FB_VISUAL_STATIC_PSEUDOCOLOR:
+		case FB_VISUAL_DIRECTCOLOR:
+			break;
+		default:
+			SDL_SetError("Unsupported console hardware");
+			BCMFB_VideoQuit(this);
+			return(-1);
+	}
+
+	/* Check if the user wants to disable hardware acceleration */
+	bcmfb_accel = SDL_getenv("SDL_BCMFB_ACCEL");
+
+	/* Memory map the device, compensating for buggy PPC mmap() */
+	mapped_offset = (((long)finfo.smem_start) -
+	                (((long)finfo.smem_start)&~(pagesize-1)));
+	mapped_memlen = finfo.smem_len+mapped_offset;
+	mapped_mem = do_mmap(NULL, mapped_memlen,
+	                  PROT_READ|PROT_WRITE, MAP_SHARED, console_fd, 0);
+	if ( mapped_mem == (char *)-1 ) {
+		SDL_SetError("Unable to memory map the video hardware");
+		mapped_mem = NULL;
+		BCMFB_VideoQuit(this);
+		return(-1);
+	}
+	else {
+		unsigned char x=1;
+		ioctl(console_fd, FBIO_SET_MANUAL_BLIT, &x);
+	}
+#ifdef BCMFB_DEBUG
+	printf("VIDEO MEM          : 0x%8x (%dMB)\n", finfo.smem_len, (finfo.smem_len/1024/1024));
+	printf("BCMFB I/O          : %p\n", mapped_mem);
+	printf("BCMFB MEM size     : 0x%8x (%dMB)\n", mapped_memlen, (mapped_memlen/1024/1024));
+#endif
+
+	/* Determine the current screen depth */
+	if ( ioctl(console_fd, FBIOGET_VSCREENINFO, &vinfo) < 0 ) {
+		SDL_SetError("Couldn't get console pixel format");
+		BCMFB_VideoQuit(this);
+		return(-1);
+	}
+	vformat->BitsPerPixel = vinfo.bits_per_pixel;
+	if ( vformat->BitsPerPixel < 8 ) {
+		/* Assuming VGA16, we handle this via a shadow framebuffer */
+		vformat->BitsPerPixel = 8;
+	}
+	for ( i=0; i<vinfo.red.length; ++i ) {
+		vformat->Rmask <<= 1;
+		vformat->Rmask |= (0x00000001<<vinfo.red.offset);
+	}
+	for ( i=0; i<vinfo.green.length; ++i ) {
+		vformat->Gmask <<= 1;
+		vformat->Gmask |= (0x00000001<<vinfo.green.offset);
+	}
+	for ( i=0; i<vinfo.blue.length; ++i ) {
+		vformat->Bmask <<= 1;
+		vformat->Bmask |= (0x00000001<<vinfo.blue.offset);
+	}
+	saved_vinfo = vinfo;
+
+	/* Save hardware palette, if needed */
+	BCMFB_SavePalette(this, &finfo, &vinfo);
+
+	/* If the I/O registers are available, memory map them so we
+	   can take advantage of any supported hardware acceleration.
+	 */
+	vinfo.accel_flags = 0;	/* Temporarily reserve registers */
+	ioctl(console_fd, FBIOPUT_VSCREENINFO, &vinfo);
+	
+	/* BCMFB acceleration */
+	if (finfo.accel) {
+		finfo.accel = FB_ACCEL_VC4;
+	}
+	
+	rotate = BCMFB_ROTATE_NONE;
+	rotation = SDL_getenv("SDL_VIDEO_BCMFB_ROTATION");
+	if (rotation != NULL) {
+		if (SDL_strlen(rotation) == 0) {
+			shadow_fb = 0;
+			rotate = BCMFB_ROTATE_NONE;
+#ifdef BCMFB_DEBUG
+			printf("Not rotating, no shadow\n");
+#endif
+		} else if (!SDL_strcmp(rotation, "NONE")) {
+			shadow_fb = 1;
+			rotate = BCMFB_ROTATE_NONE;
+#ifdef BCMFB_DEBUG
+			printf("Not rotating, but still using shadow\n");
+#endif
+		} else if (!SDL_strcmp(rotation, "CW")) {
+			shadow_fb = 1;
+			rotate = BCMFB_ROTATE_CW;
+#ifdef BCMFB_DEBUG
+			printf("Rotating screen clockwise\n");
+#endif
+		} else if (!SDL_strcmp(rotation, "CCW")) {
+			shadow_fb = 1;
+			rotate = BCMFB_ROTATE_CCW;
+#ifdef BCMFB_DEBUG
+			printf("Rotating screen counter clockwise\n");
+#endif
+		} else if (!SDL_strcmp(rotation, "UD")) {
+			shadow_fb = 1;
+			rotate = BCMFB_ROTATE_UD;
+#ifdef BCMFB_DEBUG
+			printf("Rotating screen upside down\n");
+#endif
+		} else {
+			SDL_SetError("\"%s\" is not a valid value for "
+				 "SDL_VIDEO_BCMFB_ROTATION", rotation);
+			return(-1);
+		}
+	}
+
+	if (rotate == BCMFB_ROTATE_CW || rotate == BCMFB_ROTATE_CCW) {
+		current_w = vinfo.yres;
+		current_h = vinfo.xres;
+	} else {
+		current_w = vinfo.xres;
+		current_h = vinfo.yres;
+	}
+
+	/* Query for the list of available video modes */
+	current_index = ((vinfo.bits_per_pixel+7)/8)-1;
+	modesdb = fopen(BCMFB_MODES_DB, "r");
+	for ( i=0; i<NUM_MODELISTS; ++i ) {
+		SDL_nummodes[i] = 0;
+		SDL_modelist[i] = NULL;
+	}
+	if ( SDL_getenv("SDL_BCMFB_BROKEN_MODES") != NULL ) {
+		BCMFB_AddMode(this, current_index, current_w, current_h, 0);
+	} else if(modesdb) {
+		while ( read_bcmfb_conf_mode(modesdb, &vinfo) ) {
+			for ( i=0; i<NUM_MODELISTS; ++i ) {
+				unsigned int w, h;
+
+				if (rotate == BCMFB_ROTATE_CW || rotate == BCMFB_ROTATE_CCW) {
+					w = vinfo.yres;
+					h = vinfo.xres;
+				} else {
+					w = vinfo.xres;
+					h = vinfo.yres;
+				}
+				/* See if we are querying for the current mode */
+				if ( i == current_index ) {
+					if ( (current_w > w) || (current_h > h) ) {
+						/* Only check once */
+						BCMFB_AddMode(this, i, current_w, current_h, 0);
+						current_index = -1;
+					}
+				}
+				if ( BCMFB_CheckMode(this, &vinfo, i, &w, &h) ) {
+					BCMFB_AddMode(this, i, w, h, 0);
+				}
+			}
+		}
+		fclose(modesdb);
+		BCMFB_SortModes(this);
+	} else {
+		for ( i=0; i<NUM_MODELISTS; ++i ) {
+			for ( j=0; j<(sizeof(checkres)/sizeof(checkres[0])); ++j ) {
+				unsigned int w, h;
+
+				if (rotate == BCMFB_ROTATE_CW || rotate == BCMFB_ROTATE_CCW) {
+					w = checkres[j].h;
+					h = checkres[j].w;
+				} else {
+					w = checkres[j].w;
+					h = checkres[j].h;
+				}
+				/* See if we are querying for the current mode */
+				if ( i == current_index ) {
+					if ( (current_w > w) || (current_h > h) ) {
+						/* Only check once */
+						BCMFB_AddMode(this, i, current_w, current_h, 0);
+						current_index = -1;
+					}
+				}
+				if ( BCMFB_CheckMode(this, &vinfo, i, &w, &h) ) {
+					BCMFB_AddMode(this, i, w, h, 1);
+				}
+			}
+		}
+	}
+
+	this->info.current_w = current_w;
+	this->info.current_h = current_h;
+	this->info.wm_available = 0;
+	this->info.hw_available = !shadow_fb;
+	this->info.video_mem = shadow_fb ? 0 : finfo.smem_len/1024;
+	
+	// Fill in our hardware acceleration capabilities
+	if ( bcmfb_accel ) {
+		if (!bcm_accel_init()) {
+#ifdef BCMFB_ACCEL_DEBUG
+			printf("BCMFB hardware accelerator init OK.\n");
+#endif
+			BCMFB_Accel(this, finfo.accel);
+		}
+		else {
+			SDL_SetError("BCMFB can not get hardware accelerator.");
+		}
+	}
+	if (shadow_fb) {
+		shadow_mem = (char *)SDL_malloc(mapped_memlen);
+		if (shadow_mem == NULL) {
+			SDL_SetError("BCMFB no memory for shadow");
+			return (-1);
+		} 
+	}
+
+	/* Enable mouse and keyboard support */
+	if ( BCMFB_OpenKeyboard(this) < 0 ) {
+		BCMFB_VideoQuit(this);
+		return(-1);
+	}
+	if ( BCMFB_OpenMouse(this) < 0 ) {
+		const char *sdl_nomouse;
+		sdl_nomouse = SDL_getenv("SDL_NOMOUSE");
+		if ( ! sdl_nomouse ) {
+			SDL_SetError("Unable to open mouse");
+			BCMFB_VideoQuit(this);
+			return(-1);
+		}
+	}
+
+	/* We're done! */
+	return(0);
+}
+
+static SDL_Rect **BCMFB_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	return(SDL_modelist[((format->BitsPerPixel+7)/8)-1]);
+}
+
+/* Various screen update functions available */
+static void BCMFB_DirectUpdate(_THIS, int numrects, SDL_Rect *rects);
+
+#ifdef BCMFB_DEBUG
+static void print_vinfo(struct fb_var_screeninfo *vinfo)
+{
+	fprintf(stderr, "Printing vinfo:\n");
+	fprintf(stderr, "\txres: %d\n", vinfo->xres);
+	fprintf(stderr, "\tyres: %d\n", vinfo->yres);
+	fprintf(stderr, "\txres_virtual: %d\n", vinfo->xres_virtual);
+	fprintf(stderr, "\tyres_virtual: %d\n", vinfo->yres_virtual);
+	fprintf(stderr, "\txoffset: %d\n", vinfo->xoffset);
+	fprintf(stderr, "\tyoffset: %d\n", vinfo->yoffset);
+	fprintf(stderr, "\tbits_per_pixel: %d\n", vinfo->bits_per_pixel);
+	fprintf(stderr, "\tgrayscale: %d\n", vinfo->grayscale);
+	fprintf(stderr, "\tnonstd: %d\n", vinfo->nonstd);
+	fprintf(stderr, "\tactivate: %d\n", vinfo->activate);
+	fprintf(stderr, "\theight: %d\n", vinfo->height);
+	fprintf(stderr, "\twidth: %d\n", vinfo->width);
+	fprintf(stderr, "\taccel_flags: %d\n", vinfo->accel_flags);
+	fprintf(stderr, "\tpixclock: %d\n", vinfo->pixclock);
+	fprintf(stderr, "\tleft_margin: %d\n", vinfo->left_margin);
+	fprintf(stderr, "\tright_margin: %d\n", vinfo->right_margin);
+	fprintf(stderr, "\tupper_margin: %d\n", vinfo->upper_margin);
+	fprintf(stderr, "\tlower_margin: %d\n", vinfo->lower_margin);
+	fprintf(stderr, "\thsync_len: %d\n", vinfo->hsync_len);
+	fprintf(stderr, "\tvsync_len: %d\n", vinfo->vsync_len);
+	fprintf(stderr, "\tsync: %d\n", vinfo->sync);
+	fprintf(stderr, "\tvmode: %d\n", vinfo->vmode);
+	fprintf(stderr, "\tred: %d/%d\n", vinfo->red.length, vinfo->red.offset);
+	fprintf(stderr, "\tgreen: %d/%d\n", vinfo->green.length, vinfo->green.offset);
+	fprintf(stderr, "\tblue: %d/%d\n", vinfo->blue.length, vinfo->blue.offset);
+	fprintf(stderr, "\talpha: %d/%d\n", vinfo->transp.length, vinfo->transp.offset);
+}
+static void print_finfo(struct fb_fix_screeninfo *finfo)
+{
+	fprintf(stderr, "Printing finfo:\n");
+	fprintf(stderr, "\tsmem_start = %p\n", (char *)finfo->smem_start);
+	fprintf(stderr, "\tsmem_len = %d\n", finfo->smem_len);
+	fprintf(stderr, "\ttype = %d\n", finfo->type);
+	fprintf(stderr, "\ttype_aux = %d\n", finfo->type_aux);
+	fprintf(stderr, "\tvisual = %d\n", finfo->visual);
+	fprintf(stderr, "\txpanstep = %d\n", finfo->xpanstep);
+	fprintf(stderr, "\typanstep = %d\n", finfo->ypanstep);
+	fprintf(stderr, "\tywrapstep = %d\n", finfo->ywrapstep);
+	fprintf(stderr, "\tline_length = %d\n", finfo->line_length);
+	fprintf(stderr, "\tmmio_start = %p\n", (char *)finfo->mmio_start);
+	fprintf(stderr, "\tmmio_len = %d\n", finfo->mmio_len);
+	fprintf(stderr, "\taccel = %d\n", finfo->accel);
+}
+#endif
+
+static int choose_bcmfb_conf_mode(struct fb_var_screeninfo *vinfo)
+{
+	int matched;
+	FILE *modesdb;
+	struct fb_var_screeninfo cinfo;
+
+	matched = 0;
+	modesdb = fopen(BCMFB_MODES_DB, "r");
+	if ( modesdb ) {
+		/* Parse the mode definition file */
+		while ( read_bcmfb_conf_mode(modesdb, &cinfo) ) {
+			if ( (vinfo->xres == cinfo.xres && vinfo->yres == cinfo.yres) &&
+			     (!matched || (vinfo->bits_per_pixel == cinfo.bits_per_pixel)) ) {
+				vinfo->pixclock = cinfo.pixclock;
+				vinfo->left_margin = cinfo.left_margin;
+				vinfo->right_margin = cinfo.right_margin;
+				vinfo->upper_margin = cinfo.upper_margin;
+				vinfo->lower_margin = cinfo.lower_margin;
+				vinfo->hsync_len = cinfo.hsync_len;
+				vinfo->vsync_len = cinfo.vsync_len;
+				if ( matched ) {
+					break;
+				}
+				matched = 1;
+			}
+		}
+		fclose(modesdb);
+	}
+	return(matched);
+}
+
+static int choose_bcmfb_mode(struct fb_var_screeninfo *vinfo)
+{
+	int matched;
+	int i;
+
+	/* Check for BCMFB timings */
+	matched = 0;
+	for ( i=0; i<(sizeof(BCMFB_timings)/sizeof(BCMFB_timings[0])); ++i ) {
+		if ( (vinfo->xres == BCMFB_timings[i].xres) &&
+		     (vinfo->yres == BCMFB_timings[i].yres) ) {
+#ifdef BCMFB_DEBUG
+			fprintf(stderr, "BCMFB using timings for %dx%d\n",
+						vinfo->xres, vinfo->yres);
+#endif
+			if ( BCMFB_timings[i].pixclock ) {
+				vinfo->pixclock = BCMFB_timings[i].pixclock;
+			}
+			vinfo->left_margin = BCMFB_timings[i].left;
+			vinfo->right_margin = BCMFB_timings[i].right;
+			vinfo->upper_margin = BCMFB_timings[i].upper;
+			vinfo->lower_margin = BCMFB_timings[i].lower;
+			vinfo->hsync_len = BCMFB_timings[i].hslen;
+			vinfo->vsync_len = BCMFB_timings[i].vslen;
+			vinfo->sync = BCMFB_timings[i].sync;
+			vinfo->vmode = BCMFB_timings[i].vmode;
+			matched = 1;
+			break;
+		}
+	}
+	return(matched);
+}
+
+static SDL_Surface *BCMFB_SetVideoMode(_THIS, SDL_Surface *current,
+				int width, int height, int bpp, Uint32 flags)
+{
+	struct fb_fix_screeninfo finfo;
+	struct fb_var_screeninfo vinfo;
+	int i;
+	Uint32 Rmask;
+	Uint32 Gmask;
+	Uint32 Bmask;
+	char *surfaces_mem;
+	int surfaces_len;
+
+	/* Set the terminal into graphics mode */
+	if ( BCMFB_EnterGraphicsMode(this) < 0 ) {
+		return(NULL);
+	}
+
+	/* Restore the original palette */
+	BCMFB_RestorePalette(this);
+
+	/* Set the video mode and get the final screen format */
+	if ( ioctl(console_fd, FBIOGET_VSCREENINFO, &vinfo) < 0 ) {
+		SDL_SetError("BCMFB couldn't get console screen info");
+		return(NULL);
+	}
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "BCMFB original vinfo:\n");
+	print_vinfo(&vinfo);
+#endif
+	/* Do not use double buffering with shadow buffer */
+	if (shadow_fb) {
+		flags &= ~SDL_DOUBLEBUF;
+	}
+
+	if ( (vinfo.xres != width) || (vinfo.yres != height) ||
+	     (vinfo.bits_per_pixel != bpp) || (flags & SDL_DOUBLEBUF) ) {
+		vinfo.activate = FB_ACTIVATE_NOW;
+		vinfo.accel_flags = 0;
+		vinfo.bits_per_pixel = bpp;
+		vinfo.xres = width;
+		vinfo.xres_virtual = width;
+		vinfo.yres = height;
+		if ( flags & SDL_DOUBLEBUF ) {
+			vinfo.yres_virtual = height*2;
+		} else {
+			vinfo.yres_virtual = height;
+		}
+		vinfo.xoffset = 0;
+		vinfo.yoffset = 0;
+		vinfo.red.length = vinfo.red.offset = 0;
+		vinfo.green.length = vinfo.green.offset = 0;
+		vinfo.blue.length = vinfo.blue.offset = 0;
+		vinfo.transp.length = vinfo.transp.offset = 0;
+		if ( ! choose_bcmfb_conf_mode(&vinfo) ) {
+			choose_bcmfb_mode(&vinfo);
+		}
+#ifdef BCMFB_DEBUG
+		fprintf(stderr, "BCMFB wanted vinfo:\n");
+		print_vinfo(&vinfo);
+#endif
+		if ( !shadow_fb &&
+				ioctl(console_fd, FBIOPUT_VSCREENINFO, &vinfo) < 0 ) {
+			vinfo.yres_virtual = height;
+			if ( ioctl(console_fd, FBIOPUT_VSCREENINFO, &vinfo) < 0 ) {
+				SDL_SetError("BCMFB couldn't set console screen info");
+				return(NULL);
+			}
+		}
+	} else {
+		int maxheight;
+
+		/* Figure out how much video memory is available */
+		if ( flags & SDL_DOUBLEBUF ) {
+			maxheight = height*2;
+		} else {
+			maxheight = height;
+		}
+		if ( vinfo.yres_virtual > maxheight ) {
+			vinfo.yres_virtual = maxheight;
+		}
+	}
+	cache_vinfo = vinfo;
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "BCMFB actual vinfo:\n");
+	print_vinfo(&vinfo);
+#endif
+	Rmask = 0;
+	for ( i=0; i<vinfo.red.length; ++i ) {
+		Rmask <<= 1;
+		Rmask |= (0x00000001<<vinfo.red.offset);
+	}
+	Gmask = 0;
+	for ( i=0; i<vinfo.green.length; ++i ) {
+		Gmask <<= 1;
+		Gmask |= (0x00000001<<vinfo.green.offset);
+	}
+	Bmask = 0;
+	for ( i=0; i<vinfo.blue.length; ++i ) {
+		Bmask <<= 1;
+		Bmask |= (0x00000001<<vinfo.blue.offset);
+	}
+	if ( ! SDL_ReallocFormat(current, vinfo.bits_per_pixel,
+	                                  Rmask, Gmask, Bmask, 0) ) {
+		return(NULL);
+	}
+
+	/* Get the fixed information about the console hardware.
+	   This is necessary since finfo.line_length changes.
+	 */
+	if ( ioctl(console_fd, FBIOGET_FSCREENINFO, &finfo) < 0 ) {
+		SDL_SetError("BCMFB couldn't get console hardware info");
+		return(NULL);
+	}
+
+	/* Save hardware palette, if needed */
+	BCMFB_SavePalette(this, &finfo, &vinfo);
+
+	if (shadow_fb) {
+		if (vinfo.bits_per_pixel == 16) {
+			blitFunc = (rotate == BCMFB_ROTATE_NONE ||
+					rotate == BCMFB_ROTATE_UD) ?
+				BCMFB_blit16 : BCMFB_blit16blocked;
+		} else {
+#ifdef BCMFB_DEBUG
+			fprintf(stderr, "BCMFB Init vinfo:\n");
+			print_vinfo(&vinfo);
+#endif
+			SDL_SetError("BCMFB using software buffer, but no blitter "
+					"function is available for %d bpp.",
+					vinfo.bits_per_pixel);
+			return(NULL);
+		}
+	}
+
+	/* Set up the new mode framebuffer */
+	current->flags &= SDL_FULLSCREEN;
+	if (shadow_fb) {
+		current->flags |= SDL_SWSURFACE;
+	} else {
+		current->flags |= SDL_HWSURFACE;
+	}
+	/* We have got smp */
+	current->flags |= SDL_ASYNCBLIT;
+	
+	current->w = vinfo.xres;
+	current->h = vinfo.yres;
+	if (shadow_fb) {
+		current->pitch = current->w * ((vinfo.bits_per_pixel + 7) / 8);
+		current->pixels = shadow_mem;
+		physlinebytes = finfo.line_length;
+	} else {
+		current->pitch = finfo.line_length;
+		current->pixels = mapped_mem+mapped_offset;
+	}
+	
+	/* Set up the information for hardware surfaces */
+	surfaces_mem = (char *)current->pixels +
+		vinfo.yres_virtual*current->pitch;
+	surfaces_len = (shadow_fb) ?
+		0 : (mapped_memlen-(surfaces_mem-mapped_mem));
+
+	BCMFB_FreeHWSurfaces(this);
+	BCMFB_InitHWSurfaces(this, current, surfaces_mem, surfaces_len);
+
+	/* Let the application know we have a hardware palette */
+	switch (finfo.visual) {
+		case FB_VISUAL_PSEUDOCOLOR:
+		current->flags |= SDL_HWPALETTE;
+		break;
+		default:
+		break;
+	}
+
+	/* Update for double-buffering, if we can */
+	if ( flags & SDL_DOUBLEBUF ) {
+		if ( vinfo.yres_virtual == (height*2) ) {
+			current->flags |= SDL_DOUBLEBUF;
+			flip_page = 0;
+			flip_address[0] = (char *)current->pixels;
+			flip_address[1] = (char *)current->pixels+
+				current->h*current->pitch;
+			this->screen = current;
+			BCMFB_FlipHWSurface(this, current);
+			this->screen = NULL;
+		}
+	}
+	
+	/* Set the accel mem */
+	accel_memlen = current->h*current->pitch;
+	accel_offset = (mapped_memlen/accel_memlen - 1) * accel_memlen;
+	accel_mem = (char *)current->pixels + accel_offset;
+	
+#ifdef BCMFB_ACCEL_DEBUG
+	printf("BCMFB IO I/O at    : %p\n", accel_mem);
+	printf("BCMFB_ACCEL_SIZE   : 0x%8x (%dMB)\n", accel_memlen);
+	printf("BCMFB_ACCEL_OFFSET : 0x%8x (%dMB)\n", accel_offset);
+#endif
+
+	/* Set the update rectangle function */
+	this->UpdateRects = BCMFB_DirectUpdate;
+
+	/* We're done */
+	return(current);
+}
+
+#ifdef BCMFB_DEBUG
+void BCMFB_DumpHWSurfaces(_THIS)
+{
+	vidmem_bucket *bucket;
+
+	printf("BCMFB memory left: %d (%d total)\n", surfaces_memleft, surfaces_memtotal);
+	printf("\n");
+	printf("         Base  Size\n");
+	for ( bucket=&surfaces; bucket; bucket=bucket->next ) {
+		printf("Bucket:  %p, %d (%s)\n", bucket->base, bucket->size, bucket->used ? "used" : "free");
+		if ( bucket->prev ) {
+			if ( bucket->base != bucket->prev->base+bucket->prev->size ) {
+				printf("Warning, corrupt bucket list! (prev)\n");
+			}
+		} else {
+			if ( bucket != &surfaces ) {
+				printf("Warning, corrupt bucket list! (!prev)\n");
+			}
+		}
+		if ( bucket->next ) {
+			if ( bucket->next->base != bucket->base+bucket->size ) {
+				printf("Warning, corrupt bucket list! (next)\n");
+			}
+		}
+	}
+	printf("\n");
+}
+#endif
+
+static int BCMFB_InitHWSurfaces(_THIS, SDL_Surface *screen, char *base, int size)
+{
+	vidmem_bucket *bucket;
+
+	surfaces_memtotal = size;
+	surfaces_memleft = size;
+
+	if ( surfaces_memleft > 0 ) {
+		bucket = (vidmem_bucket *)SDL_malloc(sizeof(*bucket));
+		if ( bucket == NULL ) {
+			SDL_OutOfMemory();
+			return(-1);
+		}
+		bucket->prev = &surfaces;
+		bucket->used = 0;
+		bucket->dirty = 0;
+		bucket->base = base;
+		bucket->size = size;
+		bucket->next = NULL;
+	} else {
+		bucket = NULL;
+	}
+
+	surfaces.prev = NULL;
+	surfaces.used = 1;
+	surfaces.dirty = 0;
+	surfaces.base = screen->pixels;
+	surfaces.size = (unsigned int)((long)base - (long)surfaces.base);
+	surfaces.next = bucket;
+	screen->hwdata = (struct private_hwdata *)&surfaces;
+	return(0);
+}
+static void BCMFB_FreeHWSurfaces(_THIS)
+{
+	vidmem_bucket *bucket, *freeable;
+
+	bucket = surfaces.next;
+	while ( bucket ) {
+		freeable = bucket;
+		bucket = bucket->next;
+		SDL_free(freeable);
+	}
+	surfaces.next = NULL;
+}
+
+static int BCMFB_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	fprintf(stderr, "BCMFB_AllocHWSurface\n");
+	vidmem_bucket *bucket;
+	int size;
+	int extra;
+
+/* Temporarily, we only allow surfaces the same width as display.
+   Some blitters require the pitch between two hardware surfaces
+   to be the same.  Others have interesting alignment restrictions.
+   Until someone who knows these details looks at the code...
+*/
+if ( surface->pitch > SDL_VideoSurface->pitch ) {
+	SDL_SetError("Surface requested wider than screen");
+	return(-1);
+}
+surface->pitch = SDL_VideoSurface->pitch;
+	size = surface->h * surface->pitch;
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "BCMFB allocating bucket of %d bytes\n", size);
+#endif
+
+	/* Quick check for available mem */
+	if ( size > surfaces_memleft ) {
+		SDL_SetError("Not enough video memory");
+		return(-1);
+	}
+
+	/* Search for an empty bucket big enough */
+	for ( bucket=&surfaces; bucket; bucket=bucket->next ) {
+		if ( ! bucket->used && (size <= bucket->size) ) {
+			break;
+		}
+	}
+	if ( bucket == NULL ) {
+		SDL_SetError("Video memory too fragmented");
+		return(-1);
+	}
+
+	/* Create a new bucket for left-over memory */
+	extra = (bucket->size - size);
+	if ( extra ) {
+		vidmem_bucket *newbucket;
+
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "BCMFB adding new free bucket of %d bytes\n", extra);
+#endif
+		newbucket = (vidmem_bucket *)SDL_malloc(sizeof(*newbucket));
+		if ( newbucket == NULL ) {
+			SDL_OutOfMemory();
+			return(-1);
+		}
+		newbucket->prev = bucket;
+		newbucket->used = 0;
+		newbucket->base = bucket->base+size;
+		newbucket->size = extra;
+		newbucket->next = bucket->next;
+		if ( bucket->next ) {
+			bucket->next->prev = newbucket;
+		}
+		bucket->next = newbucket;
+	}
+
+	/* Set the current bucket values and return it! */
+	bucket->used = 1;
+	bucket->size = size;
+	bucket->dirty = 0;
+#ifdef BCMFB_DEBUG
+	fprintf(stderr, "BCMFB allocated %d bytes at %p\n", bucket->size, bucket->base);
+#endif
+	surfaces_memleft -= size;
+	surface->flags |= SDL_HWSURFACE;
+	surface->pixels = bucket->base;
+	surface->hwdata = (struct private_hwdata *)bucket;
+	return(0);
+}
+static void BCMFB_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	vidmem_bucket *bucket, *freeable;
+
+	/* Look for the bucket in the current list */
+	for ( bucket=&surfaces; bucket; bucket=bucket->next ) {
+		if ( bucket == (vidmem_bucket *)surface->hwdata ) {
+			break;
+		}
+	}
+	if ( bucket && bucket->used ) {
+		/* Add the memory back to the total */
+#ifdef DGA_DEBUG
+	printf("BCMFB freeing bucket of %d bytes\n", bucket->size);
+#endif
+		surfaces_memleft += bucket->size;
+
+		/* Can we merge the space with surrounding buckets? */
+		bucket->used = 0;
+		if ( bucket->next && ! bucket->next->used ) {
+#ifdef DGA_DEBUG
+	printf("BCMFB merging with next bucket, for %d total bytes\n", bucket->size+bucket->next->size);
+#endif
+			freeable = bucket->next;
+			bucket->size += bucket->next->size;
+			bucket->next = bucket->next->next;
+			if ( bucket->next ) {
+				bucket->next->prev = bucket;
+			}
+			SDL_free(freeable);
+		}
+		if ( bucket->prev && ! bucket->prev->used ) {
+#ifdef DGA_DEBUG
+	printf("BCMFB merging with previous bucket, for %d total bytes\n", bucket->prev->size+bucket->size);
+#endif
+			freeable = bucket;
+			bucket->prev->size += bucket->size;
+			bucket->prev->next = bucket->next;
+			if ( bucket->next ) {
+				bucket->next->prev = bucket->prev;
+			}
+			SDL_free(freeable);
+		}
+	}
+	surface->pixels = NULL;
+	surface->hwdata = NULL;
+}
+
+static int BCMFB_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	if ( switched_away ) {
+		return -2; /* no hardware access */
+	}
+	if ( surface == this->screen ) {
+		SDL_mutexP(hw_lock);
+		if ( BCMFB_IsSurfaceBusy(surface) ) {
+			BCMFB_WaitBusySurfaces(this);
+		}
+	} else {
+		if ( BCMFB_IsSurfaceBusy(surface) ) {
+			BCMFB_WaitBusySurfaces(this);
+		}
+	}
+	return(0);
+}
+static void BCMFB_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	if ( surface == this->screen ) {
+		SDL_mutexV(hw_lock);
+	}
+}
+
+static void BCMFB_WaitVBL(_THIS)
+{
+	fprintf(stderr, "BCMFB_WaitVBL\n");
+#ifdef FBIOWAITRETRACE /* Heheh, this didn't make it into the main kernel */
+	ioctl(console_fd, FBIOWAITRETRACE, 0);
+#endif
+	return;
+}
+
+static void BCMFB_WaitIdle(_THIS)
+{
+	return;
+}
+
+static int BCMFB_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+	fprintf(stderr, "BCMFB_FlipHWSurface\n");
+	if ( switched_away ) {
+		return -2; /* no hardware access */
+	}
+
+	/* Wait for vertical retrace and then flip display */
+	cache_vinfo.yoffset = flip_page*surface->h;
+	if ( BCMFB_IsSurfaceBusy(this->screen) ) {
+		BCMFB_WaitBusySurfaces(this);
+	}
+	wait_vbl(this);
+	if ( ioctl(console_fd, FBIOPAN_DISPLAY, &cache_vinfo) < 0 ) {
+		SDL_SetError("ioctl(FBIOPAN_DISPLAY) failed");
+		return(-1);
+	}
+	flip_page = !flip_page;
+
+	surface->pixels = flip_address[flip_page];
+	return(0);
+}
+
+static void BCMFB_blit16(Uint8 *byte_src_pos, int src_right_delta, int src_down_delta,
+		Uint8 *byte_dst_pos, int dst_linebytes, int width, int height)
+{
+	fprintf(stderr, "BCMFB_blit16\n");
+	int w;
+	Uint16 *src_pos = (Uint16 *)byte_src_pos;
+	Uint16 *dst_pos = (Uint16 *)byte_dst_pos;
+
+	while (height) {
+		Uint16 *src = src_pos;
+		Uint16 *dst = dst_pos;
+		for (w = width; w != 0; w--) {
+			*dst = *src;
+			src += src_right_delta;
+			dst++;
+		}
+		dst_pos = (Uint16 *)((Uint8 *)dst_pos + dst_linebytes);
+		src_pos += src_down_delta;
+		height--;
+	}
+}
+
+#define BLOCKSIZE_W 32
+#define BLOCKSIZE_H 32
+
+static void BCMFB_blit16blocked(Uint8 *byte_src_pos, int src_right_delta, int src_down_delta, 
+		Uint8 *byte_dst_pos, int dst_linebytes, int width, int height)
+{
+	fprintf(stderr, "BCMFB_blit16blocked\n");
+	int w;
+	Uint16 *src_pos = (Uint16 *)byte_src_pos;
+	Uint16 *dst_pos = (Uint16 *)byte_dst_pos;
+
+	while (height > 0) {
+		Uint16 *src = src_pos;
+		Uint16 *dst = dst_pos;
+		for (w = width; w > 0; w -= BLOCKSIZE_W) {
+			BCMFB_blit16((Uint8 *)src,
+					src_right_delta,
+					src_down_delta,
+					(Uint8 *)dst,
+					dst_linebytes,
+					min(w, BLOCKSIZE_W),
+					min(height, BLOCKSIZE_H));
+			src += src_right_delta * BLOCKSIZE_W;
+			dst += BLOCKSIZE_W;
+		}
+		dst_pos = (Uint16 *)((Uint8 *)dst_pos + dst_linebytes * BLOCKSIZE_H);
+		src_pos += src_down_delta * BLOCKSIZE_H;
+		height -= BLOCKSIZE_H;
+	}
+}
+
+static void BCMFB_DirectUpdate(_THIS, int numrects, SDL_Rect *rects)
+{
+	//fprintf(stderr, "BCMFB_DirectUpdate\n");
+	if (!shadow_fb) {
+		/* init blit */
+		//fprintf(stderr,">> BCMFB_DirectUpdate blit");
+		ioctl(console_fd, FBIO_BLIT);
+		/* The application is already updating the visible video memory */
+		return;
+	}
+	int width = cache_vinfo.xres;
+	int height = cache_vinfo.yres;
+	int bytes_per_pixel = (cache_vinfo.bits_per_pixel + 7) / 8;
+	int i;
+
+	if (cache_vinfo.bits_per_pixel != 16) {
+		SDL_SetError("Shadow copy only implemented for 16 bpp");
+		return;
+	}
+
+	for (i = 0; i < numrects; i++) {
+		int x1, y1, x2, y2;
+		int scr_x1, scr_y1, scr_x2, scr_y2;
+		int sha_x1, sha_y1;
+		int shadow_right_delta;  /* Address change when moving right in dest */
+		int shadow_down_delta;   /* Address change when moving down in dest */
+		char *src_start;
+		char *dst_start;
+
+		x1 = rects[i].x; 
+		y1 = rects[i].y;
+		x2 = x1 + rects[i].w; 
+		y2 = y1 + rects[i].h;
+
+		if (x1 < 0) {
+			x1 = 0;
+		} else if (x1 > width) {
+			x1 = width;
+		}
+		if (x2 < 0) {
+			x2 = 0;
+		} else if (x2 > width) {
+			x2 = width;
+		}
+		if (y1 < 0) {
+			y1 = 0;
+		} else if (y1 > height) {
+			y1 = height;
+		}
+		if (y2 < 0) {
+			y2 = 0;
+		} else if (y2 > height) {
+			y2 = height;
+		}
+		if (x2 <= x1 || y2 <= y1) {
+			continue;
+		}
+
+		switch (rotate) {
+			case BCMFB_ROTATE_NONE:
+				sha_x1 = scr_x1 = x1;
+				sha_y1 = scr_y1 = y1;
+				scr_x2 = x2;
+				scr_y2 = y2;
+				shadow_right_delta = 1;
+				shadow_down_delta = width;
+				break;
+			case BCMFB_ROTATE_CCW:
+				scr_x1 = y1;
+				scr_y1 = width - x2;
+				scr_x2 = y2;
+				scr_y2 = width - x1;
+				sha_x1 = x2 - 1;
+				sha_y1 = y1;
+				shadow_right_delta = width;
+				shadow_down_delta = -1;
+				break;
+			case BCMFB_ROTATE_UD:
+				scr_x1 = width - x2;
+				scr_y1 = height - y2;
+				scr_x2 = width - x1;
+				scr_y2 = height - y1;
+				sha_x1 = x2 - 1;
+				sha_y1 = y2 - 1;
+				shadow_right_delta = -1;
+				shadow_down_delta = -width;
+				break;
+			case BCMFB_ROTATE_CW:
+				scr_x1 = height - y2;
+				scr_y1 = x1;
+				scr_x2 = height - y1;
+				scr_y2 = x2;
+				sha_x1 = x1;
+				sha_y1 = y2 - 1;
+				shadow_right_delta = -width;
+				shadow_down_delta = 1;
+				break;
+			default:
+				SDL_SetError("Unknown rotation");
+				return;
+		}
+
+		src_start = shadow_mem +
+			(sha_y1 * width + sha_x1) * bytes_per_pixel;
+		dst_start = mapped_mem + mapped_offset + scr_y1 * physlinebytes + 
+			scr_x1 * bytes_per_pixel;
+			
+		/* Here p is the address to the pixel we want to retrieve */
+#if 0
+		Uint16 *p = (Uint8 *)src_start + scr_y2 - scr_y1 * this->screen->pitch + scr_x2 - scr_x1 * bytes_per_pixel;
+		
+		Uint32 *color = p[ ( scr_y2 - scr_y1 * width ) + scr_x2 - scr_x1 ];
+		
+		if (FillHWRect(this, dst_start, rects[i], color)) {
+			fprintf(stderr, "BCMFB FillHWRect sw fallback\n");
+		}
+		else {
+			return;
+		}
+#endif
+			
+		blitFunc((Uint8 *) src_start,
+				shadow_right_delta, 
+				shadow_down_delta, 
+				(Uint8 *) dst_start,
+				physlinebytes,
+				scr_x2 - scr_x1,
+				scr_y2 - scr_y1);
+	}
+}
+
+void BCMFB_SavePaletteTo(_THIS, int palette_len, __u16 *area)
+{
+	fprintf(stderr, "BCMFB_SavePaletteTo\n");
+		
+	struct fb_cmap cmap;
+		
+	cmap.start = 0;
+	cmap.len = palette_len;
+	cmap.red = &area[0*palette_len];
+	cmap.green = &area[1*palette_len];
+	cmap.blue = &area[2*palette_len];
+	cmap.transp = NULL;
+	ioctl(console_fd, FBIOGETCMAP, &cmap);
+	
+}
+
+void BCMFB_RestorePaletteFrom(_THIS, int palette_len, __u16 *area)
+{
+	fprintf(stderr, "BCMFB_RestorePaletteFrom\n");
+
+	struct fb_cmap cmap;
+
+	cmap.start = 0;
+	cmap.len = palette_len;
+	cmap.red = &area[0*palette_len];
+	cmap.green = &area[1*palette_len];
+	cmap.blue = &area[2*palette_len];
+	cmap.transp = NULL;
+	ioctl(console_fd, FBIOPUTCMAP, &cmap);
+}
+
+static void BCMFB_SavePalette(_THIS, struct fb_fix_screeninfo *finfo,
+                                  struct fb_var_screeninfo *vinfo)
+{
+	int i;
+
+	/* Save hardware palette, if needed */
+	if ( finfo->visual == FB_VISUAL_PSEUDOCOLOR ) {
+		saved_cmaplen = 1<<vinfo->bits_per_pixel;
+		saved_cmap=(__u16 *)SDL_malloc(3*saved_cmaplen*sizeof(*saved_cmap));
+		if ( saved_cmap != NULL ) {
+			BCMFB_SavePaletteTo(this, saved_cmaplen, saved_cmap);
+		}
+	}
+
+	/* Added support for FB_VISUAL_DIRECTCOLOR.
+	   With this mode pixel information is passed through the palette...
+	   Neat fading and gamma correction effects can be had by simply
+	   fooling around with the palette instead of changing the pixel
+	   values themselves... Very neat!
+
+	   Adam Meyerowitz 1/19/2000
+	   ameyerow@optonline.com
+	*/
+	if ( finfo->visual == FB_VISUAL_DIRECTCOLOR ) {
+		__u16 new_entries[3*256];
+
+		/* Save the colormap */
+		saved_cmaplen = 256;
+		saved_cmap=(__u16 *)SDL_malloc(3*saved_cmaplen*sizeof(*saved_cmap));
+		if ( saved_cmap != NULL ) {
+			BCMFB_SavePaletteTo(this, saved_cmaplen, saved_cmap);
+		}
+
+		/* Allocate new identity colormap */
+		for ( i=0; i<256; ++i ) {
+	      		new_entries[(0*256)+i] =
+			new_entries[(1*256)+i] =
+			new_entries[(2*256)+i] = (i<<8)|i;
+		}
+		BCMFB_RestorePaletteFrom(this, 256, new_entries);
+	}
+}
+
+static void BCMFB_RestorePalette(_THIS)
+{
+	/* Restore the original palette */
+	if ( saved_cmap ) {
+		BCMFB_RestorePaletteFrom(this, saved_cmaplen, saved_cmap);
+		SDL_free(saved_cmap);
+		saved_cmap = NULL;
+	}
+}
+
+static int BCMFB_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
+{
+	fprintf(stderr, "BCMFB_SetColors\n");
+	int i;
+	__u16 r[256];
+	__u16 g[256];
+	__u16 b[256];
+	struct fb_cmap cmap;
+
+	/* Set up the colormap */
+	for (i = 0; i < ncolors; i++) {
+		r[i] = colors[i].r << 8;
+		g[i] = colors[i].g << 8;
+		b[i] = colors[i].b << 8;
+	}
+
+	cmap.start = firstcolor;
+	cmap.len = ncolors;
+	cmap.red = r;
+	cmap.green = g;
+	cmap.blue = b;
+	cmap.transp = NULL;
+
+	if( (ioctl(console_fd, FBIOPUTCMAP, &cmap) < 0) ||
+	    !(this->screen->flags & SDL_HWPALETTE) ) {
+	        colors = this->screen->format->palette->colors;
+		ncolors = this->screen->format->palette->ncolors;
+		cmap.start = 0;
+		cmap.len = ncolors;
+		SDL_memset(r, 0, sizeof(r));
+		SDL_memset(g, 0, sizeof(g));
+		SDL_memset(b, 0, sizeof(b));
+		if ( ioctl(console_fd, FBIOGETCMAP, &cmap) == 0 ) {
+			for ( i=ncolors-1; i>=0; --i ) {
+				colors[i].r = (r[i]>>8);
+				colors[i].g = (g[i]>>8);
+				colors[i].b = (b[i]>>8);
+			}
+		}
+		return(0);
+	}
+	return(1);
+}
+
+/* Note:  If we are terminated, this could be called in the middle of
+   another SDL video routine -- notably UpdateRects.
+*/
+static void BCMFB_VideoQuit(_THIS)
+{
+	int i, j;
+
+	if ( this->screen ) {
+		/* Clear screen and tell SDL not to free the pixels */
+
+		const char *dontClearPixels = SDL_getenv("SDL_BCMFB_DONT_CLEAR");
+
+		/* If the framebuffer is not to be cleared, make sure that we won't
+		 * display the previous frame when disabling double buffering. */
+		if ( dontClearPixels && flip_page == 0 ) {
+			SDL_memcpy(flip_address[0], flip_address[1], this->screen->pitch * this->screen->h);
+		}
+
+		if ( !dontClearPixels && this->screen->pixels && BCMFB_InGraphicsMode(this) ) {
+			SDL_memset(this->screen->pixels,0,this->screen->h*this->screen->pitch);
+		}
+		/* This test fails when using the VGA16 shadow memory */
+		if ( ((char *)this->screen->pixels >= mapped_mem) &&
+		     ((char *)this->screen->pixels < (mapped_mem+mapped_memlen)) ) {
+			this->screen->pixels = NULL;
+		}
+	}
+
+	/* Clear the lock mutex */
+	if ( hw_lock ) {
+		SDL_DestroyMutex(hw_lock);
+		hw_lock = NULL;
+	}
+
+	/* Clean up defined video modes */
+	for ( i=0; i<NUM_MODELISTS; ++i ) {
+		if ( SDL_modelist[i] != NULL ) {
+			for ( j=0; SDL_modelist[i][j]; ++j ) {
+				SDL_free(SDL_modelist[i][j]);
+			}
+			SDL_free(SDL_modelist[i]);
+			SDL_modelist[i] = NULL;
+		}
+	}
+
+	/* Clean up the memory bucket list */
+	BCMFB_FreeHWSurfaces(this);
+
+	/* Close console and input file descriptors */
+	if ( console_fd > 0 ) {
+		unsigned char x=0;
+		ioctl(console_fd, FBIO_SET_MANUAL_BLIT, &x);
+		/* Unmap the video framebuffer and I/O registers */
+		if ( mapped_mem ) {
+			munmap(mapped_mem, mapped_memlen);
+			mapped_mem = NULL;
+		}
+		/* Restore the original video mode and palette */
+		if ( BCMFB_InGraphicsMode(this) ) {
+			BCMFB_RestorePalette(this);
+			ioctl(console_fd, FBIOPUT_VSCREENINFO, &saved_vinfo);
+		}
+
+		/* We're all done with the framebuffer */
+		close(console_fd);
+		console_fd = -1;
+	}
+	BCMFB_CloseMouse(this);
+	BCMFB_CloseKeyboard(this);
+}
diff -Nur SDL-1.2.15/src/video/bcmfb/SDL_fbvideo.h SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbvideo.h
--- SDL-1.2.15/src/video/bcmfb/SDL_fbvideo.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/bcmfb/SDL_fbvideo.h	2016-02-16 14:29:38.000000000 +0100
@@ -0,0 +1,174 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_fbvideo_h
+#define _SDL_fbvideo_h
+
+#include <sys/types.h>
+#include <termios.h>
+#include <linux/fb.h>
+
+#include "SDL_mouse.h"
+#include "SDL_mutex.h"
+#include "../SDL_sysvideo.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *this
+
+typedef void BCMFB_bitBlit(
+		Uint8 *src_pos,
+		int src_right_delta,	/* pixels, not bytes */
+		int src_down_delta,		/* pixels, not bytes */
+		Uint8 *dst_pos,
+		int dst_linebytes,
+		int width,
+		int height);
+
+/* This is the structure we use to keep track of video memory */
+typedef struct vidmem_bucket {
+	struct vidmem_bucket *prev;
+	int used;
+	int dirty;
+	char *base;
+	unsigned int size;
+	struct vidmem_bucket *next;
+} vidmem_bucket;
+
+/* Private display data */
+struct SDL_PrivateVideoData {
+
+	struct fb_var_screeninfo cache_vinfo;
+	struct fb_var_screeninfo saved_vinfo;
+	int saved_cmaplen;
+	__u16 *saved_cmap;
+
+	int console_fd;
+	int kbd_index;
+	int m_index;
+	int kbd_fd[32];
+	int mice_fd[32];
+	int panel;
+	int kbd;
+	int arc;
+	int rc;
+	
+	char *mapped_mem;
+	char *accel_mem;
+	char *shadow_mem;
+	int mapped_memlen;
+	int mapped_offset;
+	int accel_offset;
+	int accel_memlen;
+	int flip_page;
+	char *flip_address[2];
+	int rotate;
+	int shadow_fb;				/* Tells whether a shadow is being used. */
+	BCMFB_bitBlit *blitFunc;
+	int physlinebytes;			/* Length of a line in bytes in physical fb */
+
+#define NUM_MODELISTS	4		/* 8, 16, 24, and 32 bits-per-pixel */
+	int SDL_nummodes[NUM_MODELISTS];
+	SDL_Rect **SDL_modelist[NUM_MODELISTS];
+
+	vidmem_bucket surfaces;
+	int surfaces_memtotal;
+	int surfaces_memleft;
+
+	SDL_mutex *hw_lock;
+	int switched_away;
+	struct fb_var_screeninfo screen_vinfo;
+	Uint32 screen_arealen;
+	Uint8 *screen_contents;
+	__u16  screen_palette[3*256];
+
+	void (*wait_vbl)(_THIS);
+	void (*wait_idle)(_THIS);
+};
+/* Old variable names */
+#define console_fd			(this->hidden->console_fd)
+#define kbd_fd				(this->hidden->kbd_fd)
+#define kbd_index			(this->hidden->kbd_index)
+#define mice_fd				(this->hidden->mice_fd)
+#define m_index				(this->hidden->m_index)
+#define panel				(this->hidden->panel)
+#define kbd					(this->hidden->kbd)
+#define arc					(this->hidden->arc)
+#define rc					(this->hidden->rc)
+#define cache_vinfo			(this->hidden->cache_vinfo)
+#define saved_vinfo			(this->hidden->saved_vinfo)
+#define saved_cmaplen		(this->hidden->saved_cmaplen)
+#define saved_cmap			(this->hidden->saved_cmap)
+#define mapped_mem			(this->hidden->mapped_mem)
+#define shadow_mem			(this->hidden->shadow_mem)
+#define mapped_memlen		(this->hidden->mapped_memlen)
+#define mapped_offset		(this->hidden->mapped_offset)
+#define accel_memlen       	(this->hidden->accel_memlen)
+#define accel_offset     	(this->hidden->accel_offset)
+#define accel_mem       	(this->hidden->accel_mem)
+#define flip_page			(this->hidden->flip_page)
+#define flip_address		(this->hidden->flip_address)
+#define rotate				(this->hidden->rotate)
+#define shadow_fb			(this->hidden->shadow_fb)
+#define blitFunc			(this->hidden->blitFunc)
+#define physlinebytes		(this->hidden->physlinebytes)
+#define SDL_nummodes		(this->hidden->SDL_nummodes)
+#define SDL_modelist		(this->hidden->SDL_modelist)
+#define surfaces			(this->hidden->surfaces)
+#define surfaces_memtotal	(this->hidden->surfaces_memtotal)
+#define surfaces_memleft	(this->hidden->surfaces_memleft)
+#define hw_lock				(this->hidden->hw_lock)
+#define switched_away		(this->hidden->switched_away)
+#define screen_vinfo		(this->hidden->screen_vinfo)
+#define screen_arealen		(this->hidden->screen_arealen)
+#define screen_contents		(this->hidden->screen_contents)
+#define screen_palette		(this->hidden->screen_palette)
+#define wait_vbl			(this->hidden->wait_vbl)
+#define wait_idle			(this->hidden->wait_idle)
+
+
+/* These functions are defined in SDL_fbvideo.c */
+extern void BCMFB_SavePaletteTo(_THIS, int palette_len, __u16 *area);
+extern void BCMFB_RestorePaletteFrom(_THIS, int palette_len, __u16 *area);
+
+/* These are utility functions for working with video surfaces */
+
+static __inline__ void BCMFB_AddBusySurface(SDL_Surface *surface)
+{
+	((vidmem_bucket *)surface->hwdata)->dirty = 1;
+}
+
+static __inline__ int BCMFB_IsSurfaceBusy(SDL_Surface *surface)
+{
+	return ((vidmem_bucket *)surface->hwdata)->dirty;
+}
+
+static __inline__ void BCMFB_WaitBusySurfaces(_THIS)
+{
+	vidmem_bucket *bucket;
+
+	/* Wait for graphic operations to complete */
+	wait_idle(this);
+
+	/* Clear all surface dirty bits */
+	for ( bucket=&surfaces; bucket; bucket=bucket->next ) {
+		bucket->dirty = 0;
+	}
+}
+
+static __inline__ void BCMFB_dst_to_xy(_THIS, SDL_Surface *dst, int *x, int *y)
+{
+	*x = (long)((char *)dst->pixels - mapped_mem)%this->screen->pitch;
+	*y = (long)((char *)dst->pixels - mapped_mem)/this->screen->pitch;
+	if ( dst == this->screen ) {
+		*x += this->offset_x;
+		*y += this->offset_y;
+	}
+}
+
+#endif /* _SDL_fbvideo_h */
diff -Nur SDL-1.2.15/src/video/SDL_surface.c SDL-bcmfb-1.2.15/src/video/SDL_surface.c
--- SDL-1.2.15/src/video/SDL_surface.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/SDL_surface.c	2016-02-16 16:05:19.000000000 +0100
@@ -29,6 +29,54 @@
 #include "SDL_pixels_c.h"
 #include "SDL_leaks.h"
 
+#include "SDL_surface.h"
+
+/* check bcm accel */
+int 
+bcm_can_accel(SDL_Surface *dst) {
+	
+	int stride, height, bpp;
+	bpp = dst->format->BitsPerPixel;
+	height = dst->h;
+	stride = dst->w * bpp/8;
+	
+	if ((bpp != 8) || (bpp != 16) || (bpp != 32) || (stride < 48)) {
+		fprintf(stderr, "FillHWRect is no candidate for accel stride=%d bpp=%d\n", stride, bpp);
+		return(0);
+	}
+	
+	switch (bpp)
+	{
+		case 8:
+			if ((height * stride) > 12000) {
+				break;
+			}
+			else {
+				fprintf(stderr, "FillHWRect is no candidate for accel (height * stride) %d < 12000\n", (height * stride));
+				return(0);
+			}
+		case 16:
+			if ((height * stride) > 32000) {
+				break;
+			}
+			else {
+				fprintf(stderr, "FillHWRect is no candidate for accel (height * stride) %d < 32000\n", (height * stride));
+				return(0);
+			}
+		case 32:
+			if ((height * stride) > 48000) {
+				break;
+			}
+			else {
+				fprintf(stderr, "FillHWRect is no candidate for accel (height * stride) %d < 48000\n", (height * stride));
+				return(0);
+			}
+		default:
+			fprintf(stderr, "FillHWRect is no candidate for accel\n");
+			return(0);
+	}
+	return (1);
+}
 
 /* Public routines */
 /*
@@ -585,7 +633,7 @@
 
 	/* Check for hardware acceleration */
 	if ( ((dst->flags & SDL_HWSURFACE) == SDL_HWSURFACE) &&
-					video->info.blit_fill ) {
+					video->info.blit_fill && bcm_can_accel(dst)) {
 		SDL_Rect hw_rect;
 		if ( dst == SDL_VideoSurface ) {
 			hw_rect = *dstrect;
diff -Nur SDL-1.2.15/src/video/SDL_surface.h SDL-bcmfb-1.2.15/src/video/SDL_surface.h
--- SDL-1.2.15/src/video/SDL_surface.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/SDL_surface.h	2016-02-16 16:05:28.000000000 +0100
@@ -0,0 +1,15 @@
+/* bcmfb based SDL video driver implementation.
+*  SDL - Simple DirectMedia Layer
+*  Copyright (C) 1997-2012 Sam Lantinga
+*  
+*  SDL bcmfb backend
+*  Copyright (C) 2016 Emanuel Strobel
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_surface_h
+#define _SDL_surface_h
+
+extern int bcm_can_accel(SDL_Surface *dst);
+
+#endif /* _SDL_sysvideo_h */
diff -Nur SDL-1.2.15/src/video/SDL_sysvideo.h SDL-bcmfb-1.2.15/src/video/SDL_sysvideo.h
--- SDL-1.2.15/src/video/SDL_sysvideo.h	2012-01-19 07:30:06.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/SDL_sysvideo.h	2016-02-16 00:03:07.497192935 +0100
@@ -341,6 +341,9 @@
 #if SDL_VIDEO_DRIVER_FBCON
 extern VideoBootStrap FBCON_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_BCMFB
+extern VideoBootStrap BCMFB_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DIRECTFB
 extern VideoBootStrap DirectFB_bootstrap;
 #endif
diff -Nur SDL-1.2.15/src/video/SDL_video.c SDL-bcmfb-1.2.15/src/video/SDL_video.c
--- SDL-1.2.15/src/video/SDL_video.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-bcmfb-1.2.15/src/video/SDL_video.c	2016-02-16 00:03:07.497192935 +0100
@@ -57,6 +57,9 @@
 #if SDL_VIDEO_DRIVER_FBCON
 	&FBCON_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_BCMFB
+	&BCMFB_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DIRECTFB
 	&DirectFB_bootstrap,
 #endif
